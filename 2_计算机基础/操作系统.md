# 操作系统

# 1.内核

## 1.1  内核空间与用户空间

### 内核空间

内核空间是操作系统 **内核所在的内存区域**，具有**最高权限**，可以 **直接访问硬件和管理系统资源**。内核空间负责 **处理底层的系统操作**，如内存管理、进程调度、设备驱动、文件系统管理和网络通信等。

**操作系统的内核是操作系统的核心部分，它负责系统的内存管理、硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。**

### 用户空间

用户空间是 **普通应用程序运行的内存区域**，**权限受限**，**不能直接访问硬件或执行特权指令**。用户空间主要运行用户应用程序，如浏览器、文本编辑器、游戏等。

用户态和内核态是计算机操作系统中的两种运行状态，它们定义了程序在**运行时的权限和资源访问范围。同时具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能。**

## 1.2 内核和CPU的区别

内核属于**操作系统层面**，而CPU属于**硬件层面**

![Untitled](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/Untitled.png)

## 1.3 系统调用

应用程序需要进入内核空间，就需要通过系统调用。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image.png)

## 1.4 内核架构

- 宏内核：Linux 包含多个模块，整个内 核像一个完整的程序。
- 微内核：有一个最小版本的内核，一些模块和服务由用户态管理。
- 混合内核：Windos，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序。

## 1.5 软中断与硬中断

中断是计算机系统中的一种机制，用于**暂时中断当前正在执行的程序，转而处理某些紧急事件或请求。**

根据**中断的实现方式**，中断可分为硬中断（Hardware Interrupt）和软中断(Software Interrupt)。

- **硬中断（Hardware Interrupt）**

硬中断是**由硬件设备触发的中断**。(键盘按键、鼠标移动、硬盘读写完成、网络数据包到达等)当硬件设备需要CPU的注意时，它会通过硬件信号向CPU发送中断请求。

- **软中断（Software Interrupt）**

软中断是由**软件程序主动触发的中断**，通常是通过执行特定的指令（如int指令）来模拟硬件中断的效果。

### 外部中断和内部中断

根据**中断的触发源**分类

**外部中断**是由CPU外部设备（如键盘、鼠标、硬盘、网卡等）触发的，用于通知CPU有重要事件需要处理。

**内部中断**是由**CPU内部执行指令或异常**触发的，通常与程序执行错误或特殊指令相关。
外部内部中断的处理通常是在**内核态**进行的，不是在用户态。

## 1.6 有哪些内核态指令？（考过）

只能在操作系统内核态（Kernel Mode）下执行的指令。这些指令通常涉及对硬件资源的直接操作或对系统关键数据的访问，因此不允许用户态（User Mode）程序直接执行，以防止系统崩溃或安全漏洞。

- **处理器模式切换指令：用于切换CPU的运行模式**

**syscall / sysenter：**从用户态切换到内核态，触发系统调用。**sysexit / iret：**从内核态返回到用户态

- **内存管理指令：用于管理内存地址空间、页表和内存保护。**

**invlpg：**使TLB（Translation Lookaside Buffer）中的特定页表项失效。
**lgdt / lidt：**加载全局描述符表（GDT）或中断描述符表（IDT）。

- **中断和异常处理指令：用于处理硬件中断和异常。**

**int：**触发软件中断。
**cli：**禁用中断（Clear Interrupt Flag）。
**sti：**启用中断（Set Interrupt Flag）。
**iret：**从中断或异常处理程序返回。

- **I/O操作指令**

**in：**从I/O端口读取数据。
**out：**向I/O端口写入数据。

# 2. 进程与线程

## 2.1  线程中为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？

### 2.1.1 程序计数器

字节码解释器通过改变**程序计数器来依次读取指令**，从而**实现代码的流程控制**，如：顺序执行、选择、循环、异常处理。

在多线程的情况下，**程序计数器用于记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置。**

### 2.1.2 虚拟机栈和本地方法栈

**虚拟机栈：** 每个 Java 方法在执行之前会创建一个 **栈帧用于存储局部变量表、操作数栈、常量池引用等信息。** 从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

**本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。这些在JVM中有详细介绍**

## 2.2  进程和线程之间的区别

• **本质区别：**进程是**操作系统资源分配**的基本单位，而线程是**任务调度和执行**的基本单位。
• **在开销方面**：每个进程都有**独立的代码和数据空间（程序上下文）**，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，**同一类线程共享代码和数据空间，**每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

• **内存分配方面**：系统在运行的时候会为**每个进程分配不同的内存空间**；而对线程而言，除了CPU外，**系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源）**，线程组之间只能共享资源。

•  **包含关系**：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；**线程是进程的一部分**，所以线程也被称为轻权进程或者轻量级进程。

![Untitled](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/Untitled%201.png)

### 进程的控制结构

**进程控制块（PCB）PCB是进程存在的唯一标识 PCB具体包含信息：**

**1、进程描述信息**

- 进程标识符：标识各个进程，**每个进程都有一个并且唯一的标识符**；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

**2、进程控制和管理信息**

- **进程当前状态，**如new、ready、running、waiting或blocked；
- **进程优先级：**进程抢占CPU时的优先级；

**3、资源分配清单**

- 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的I/O设备信息。

**4、CPU相关信息**

- CPU中各个寄存器的值，当进程被切换时，CPU的状态信息都会被保存在相应的PCB中，以便进程重新执行时，能从断点处继续执行。

### PCB如何组织？

通过链表的方式进行组织，**把具有相同状态的进程链在一起，组成各种队列。**

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%201.png)

### 操作系统在进行线程切换时需要进行哪些动作？

Step1、保存当前线程的上下文,将当前线程的寄存器状态（如程序计数器、堆栈指针、通用寄存器等）**保存到其线程控制块（TCB）**中。

Step2、**选择下一个线程,**根据调度算法（如轮转、优先级等），从就绪队列中选择下一个要执行的线程。

Step3、**加载下一个线程的上下文：从新线程的TCB中恢复其寄存器状态**，包括程序计数器、堆栈指针等。

Step4、切换堆栈: 将当前堆栈指针切换到新线程的堆栈。

Step5、**如果新线程属于不同进程，**需**更新MMU以切换地址空间。**

Step6、恢复执行：恢复新线程的执行，**程序计数器指向新线程的下一条指令。**

## 2.3 进程间的通信方式

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%202.png)

### 2.3.1 匿名管道

**匿名管道**顾名思义，**它没有名字标识，匿名管道是特殊文件 只存在于内存，没有存在于文件系统中**

- **单向通信**

shell 命令中的「`|`」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，**通信的方式是单向的，数据只能在一个方向上流动**，如果要双向通信，需要创建两个管道。

- **只存在具有亲缘关系之间的进程**

匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。

### 2.3.2 命名管道

**存在于文件系统中、不限制血缘关系。**

**命名管道** 突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。

另外，**不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则。**

### 2.3.3 消息队列

是一个简单的数据结构，发送方和接收方无需同时运行，消息暂存于内核队列。**消息队列由内核维护，**进程退出后消息仍保留（除非显式删除或系统重启）。

允许进程将消息发送到队列中，其他进程可以从队列中读取消息。克服了管道通信的数据是无格式的字节流的问题，消息队列的消息体是可以**用户自定义的数据类型**，发送数据时，会被分成一个一个独立的消息体，**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**

### 2.3.4 共享内存

**解决消息队列通信中用户态和内核态之间数据拷贝带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问。带来新问题：**多进程竞争同个共享资源会造成数据的错乱。**这是就需要信号量来保护共享资源。

### 2.3.5 信号

信号是一种 **轻量级的通信方式** ，通常用于通知进程某些事件（如中断、错误等），而 **不是传递大量数据。**

**对于异常情况下的工作模式，**就需要用「信号」的方式来通知进程。

### 2.3.6 信号量

信号量是操作系统提供的一种协调共享资源访问的方法，**通常信号量表示资源的数量，**对应的变量是一个整型(sem)变量。另外，还有两个原子操作的系统调用函数来控制信号量：

- **P操作：将sem-1,如果sem < 0，则 进程/线程 进入阻塞等待，否则继续操作，表明P操作可能会阻塞**
- **V操作：将sem+1，如果sem ≤ 0，唤醒一个等待中的 进程/线程 ,表明V操作不会阻塞。**

### 2.3.7 **Socket**

**前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信；不同主机间通信，需要 Socket 通信了。**

## 2.4 线程间通信（不是进程通信）

- **锁机制**

**互斥锁**：线程可以使用互斥锁来保护共享资源，确保同时只有一个线程可以访问该资源。

**读写锁：**允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。读写锁适用于能明确区分读操作和写操作的场景。

- **条件变量（Condition Variable）**

线程可以使用条件变量来**等待特定条件的发生**，**（等待—> 唤醒）**以实现线程间的协调和通知。

- **信号量(Semaphore)**

信号量可以是命名的【也可以是无名的】，用于控制对资源的访问次数，通常信号量**表示资源的数量**。

- **屏障（Barrier）**

可以用来同步多个线程，确保所有线程到达某个点后再继续执行。**适合分阶段任务的同步。**

其他一些进程间通信线程也同样适用，比如共享内存、消息队列、管道等

## 2.5 僵尸进程与孤儿进程

在 Unix/Linux 系统中，子进程通常是**通过 fork()系统调用创建的**，该调用会创建一个新的进程，该进程是原有进程的一个副本。**子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB**，即使父进程结束了，子进程仍然可以继续运行。**(孤儿进程)**

当一个进程调用 **exit()**系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB 依然存在于系统中。**（僵尸进程）**这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。

- **僵尸进程**

**子进程已经终止，但是其父进程仍在运行。且父进程没有调用wait()或waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的PCB依然存在于系统中，但无法进一步被使用** 这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。子进程已经死了，但是它灵魂还在（PCB），就像僵尸一样。

- **孤儿进程**

**一个进程的父进程已经终止或不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。**

爹死了，就像孤儿一样😭为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。

## 2.6 线程与进程的生命周期

**进程的生命周期状态：**

1. **新建状态 (New)**：进程被创建，但尚未开始执行。
2. **就绪状态 (Ready)**：进程已准备好执行，但等待 CPU 分配。
3. **运行状态 (Running)**：进程获得 CPU 资源，正在执行。
4. **阻塞状态 (Blocked)**：进程因等待某些事件或资源而无法运行（如 I/O 操作）。
5. **终止状态 (Terminated)**：进程执行完毕或被强制终止，释放资源。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%203.png)

**线程的生命周期状态：**

1. **新建状态 (New)**：线程被创建，但尚未启动。
2. **就绪状态 (Runnable)**：线程准备好执行，等待调度器分配 CPU。
3. **运行状态 (Running)**：线程正在 CPU 上执行。
4. **阻塞状态 (Blocked)**：线程等待获取锁或资源，无法继续执行。
5. **时间等待状态 (Timed Waiting)：线程等待一段时间，之后自动进入就绪状态。**
6. **终止状态 (Terminated)**：线程执行完毕，资源被释放。

**总结：大体上是差不多的，但线程相对来说，多了一个时间等待状态**

## 2.7 进程同步方式 → 解决多线程冲突问题

### 1、互斥锁

### 2、信号量

### 3、条件变量

### 4、读写锁、屏障、原子操作

## 2.8 进程调度策略

### 调度

选择一个进程运行是在操作系统中完成的，通常称为调度程序

### 调度时机

在进程的生命周期中，当进程从一个运行状态到另一个状态变化的时候，其实会触发一次调度

### 调度原则

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%204.png)

### 调度算法

**1、先来先服务调度算法**

每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。

**2、最短作业优先算法**

**优先选择运行时间最短的进程来运行**

**3、高响应比优先调度算法**

理想的调度算法，实际情况根本实现不了

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%205.png)

每次进行进程调度时，先计算【响应比优先级】，然后把【响应比优先级】最高的进程投入运行

**4、时间片轮转调度算法**

最古老、最简单

每个进程被分配一个时间段，称为时间片，即允许，该进程在该时间段中允许。如果时间片用完，进程还在运行，那么将会把此进程从CPU释放出来，并把CPU分配给另外一个进程；

如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换。

**5、最高优先级调度算法**

**就绪队列中选择最高优先级的进程进行运行(这里的优先级，可以是一开始就确定好了，也可以根据进程的动态变化调整优先级)**

**6、多级反馈队列调度算法**

「时间片轮转算法」和「最高优先级算法」的综合和发展。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%206.png)

「多级」表示有多个队列，每个队列优先级从高到低，同时 **优先级越高时间片越短。**

「反馈」表示如果有新的进程加入优先级高的队列时，**立刻停止当前正在运行的进程，转而去运行优先级高的队列。**

工作：

设置了多个队列，赋予每个队列不同的优先级，每个 **队列优先级从高到低**，同时 **优先级越高时间片越短**；
新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；

当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；

## 2.9 死锁

概念：两个线程都在**等待对方释放锁**，**在没有外力的作用下，这些线程没办法继续运行，即死锁。**

产生条件：

**1、互斥条件：**多个线程不能同时使用一个资源。

**2、持有并等待条件：**线程A在等待资源2的同时并不会释放资源1。

**3、不可剥夺条件：**当线程已经有了资源，在自己使用完之前不能被其他线程获取。

**4、环路等待条件：**在死锁发生时，两个线程获取资源的顺序构成了环形链。

### 解决方法

**1、破坏循环等待条件：**资源有序分配，所有线程**按固定顺序申请资源**，避免循环等待。

**2、破坏持有并等待条件：**一次性申请所有资源。

**3、使用超时机制：**尝试获取锁时设置超时，若失败则释放已持有的锁，避免无限等待。

### 银行家算法

**基本思想（资源分配拒绝）**：系统中所有的进程放入集合，在安全状态下，系统收到进程的资源请求后，先把资源试探性地分配给它。

现在，**系统将剩下的可用资源和进程集合中其他进程还需要的资源数做比较，找到剩余资源能满足最大需求量的进程**，从而保证进程运行完毕并归还全部资源，这是把这个进程从进程集合中删除，归还其占用的所有资源，系统剩余资源则更多，反复执行上述步骤。

例如下：

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%207.png)

优先分配给P1，P1完成后释放资源，接下来分配给P2，依此类推。

# 3. 内存管理

## 3.1 内存管理基本概念

### 逻辑地址

**逻辑地址是指在程序中使用的地址**，它是程序员在编写程序时使用的地址。在编写程序时，程序员不需要关心实际的物理内存地址，而是使用逻辑地址来引用数据。逻辑地址通常是由编译器或汇编器生成的，它们是相对于程序的起始地址的偏移量。

### 虚拟地址

虚拟地址和逻辑地址在某些上下文中可以互换使用，但是它们之间有细微的概念差别。

逻辑地址是由**程序**生成的地址，通常是相对于程序代码段的偏移量。虚拟地址是**操作系统**为每个进程提供的抽象地址空间，也称为线性地址。

### 物理地址

**物理地址（Physical Address） 是真正的物理内存中地址**，更具体点来说是**内存地址寄存器中的地址。**

操作系统一般通过CPU中的一个重要组件**MMU**将虚拟地址转换成为物理地址，这个过程被称为 **地址翻译/地址转换（Address Translation）**

![Untitled](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/Untitled%202.png)

**MMU （内存管理单元）：**将虚拟地址翻译为物理地址的主要机制有两种: **分段机制** 和 **分页机制** 。

### 内存保护

装入了一个程序的同时，整个OS可能会有其他程序正在运行。**当前程序正在运行的过程中，保护此内存地址不受其他用户进程的影响。**

上下限寄存器：将运行时的最大物理地址和最小物理地址放在寄存器中记录。

### 内存碎片

- **内部碎片**

**内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经分配给进程使用但未被使用的内存**。导致内部内存碎片的主要原因是，当**采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。**

- **外部碎片**

**外部内存碎片(External Memory Fragmentation，简称为外部碎片)**：**由于未分配的连续内存区域太小，**以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片

![Untitled](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/Untitled%203.png)

---

### 内存扩充

内存扩充通常指的是增加计算机系统中的内存容量，**以提高其处理数据和运行程序的能力。**就比如我只有1G的磁盘空间，但要在其上运行2G的程序。

内存扩充的两种方式：**覆盖与交换**

**覆盖：**拿出一定大小的空间专门用于覆盖（可以被覆盖的。如果有新文件进来，就**专门放到这个覆盖区**）。

**交换：** 利用硬盘缓存（就是前面提到的那个），有些文件的访问频率不是很高，那就**先把它交换到外存中。**

## 3.2 内存管理方式

内存管理方式可以简单分为下面两种：

- **连续内存管理**：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。
- **非连续内存管理**：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些

### 连续分配管理方式

分配用户进程的时候，分配的内存空间是**连续的。**

**块式管理** 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。

块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。

除了内部内存碎片之外，两个内存块之间可能还会有外部内存碎片。

**伙伴系统算法**

Linux系统中，经典的连续内存分配算法。

伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（注意：**必须是相邻的才是伙伴**）。

进行内存分配时，伙伴系统会尝试找到 **大小最合适的内存块**。如果找到的内存块过大，就将其一分为二，**分成两个大小相等的伙伴块。**如果还是大的话，就 **继续切分，直到到达合适的大小为止。**

假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%208.png)

虽然解决了外部内存碎片的问题，但伙伴系统仍然存在内部内存碎片。

### 非连续分配管理方式（重要）

让多个非连续的内存空间拼接够足以让进程使用的空间。主要有分页、分段、段页式三种管理机制。

**分段**和**分页**是操作系统中两种主要的内存管理技术，用于**将程序的逻辑地址空间映射到物理内存。**

**基本分页存储管理方式**

分页其实就是**固定分区，**把整个虚拟和物理内存空间切成一段段固定尺寸的大小**（页，Linux下，每页的大小为 4kb）**

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%209.png)

1、需要一个数据结构去记录当前用户进程所需要的空间大小。页表是存储在内存里的，**内存管理单元（MMU）就做将虚拟内存地址转换成物理地址的工作。**

2、虚拟地址与物理地址之间通过**页表**来映射

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2010.png)

**优点**

1、采用了分页，**页与页之间是紧密排列的，所以不会有外部碎片。**

**2、内存交换效率较高**，如果内存不够，操作系统会把其他正在运行的进程中的【最近没被使用】的内存页面给释放掉，也就是暂时写在硬盘上（换出）。一旦需要的时候，再加载进来，称为换入。

注：缺点：程序不足一个页的大小也会分配页，内存分页机制**会存在内部碎片现象。**

1、页式管理中地址空间是一维的

2、每次访存都需要地址转换，必须足够快

3、页表不能太大，会降低内存利用率

**分页机制下，虚拟地址和物理地址是如何映射的？**

虚拟地址分两部分：**页号 页内偏移**

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2011.png)

存在缺陷：空间上的缺陷，因为操作系统是多进程的，所以页表会非常庞大。解决方案↓

**两级页表**

页表连续存放，占用大量连续空间。一段时间内只需要访问部分特定页面。我们可以使用两级页表来优化操作。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2012.png)

将逻辑地址拆成三部分，**从PCB读出页目录表始址，根据一级页号查出二级页表位置。根据二级页号查内存块号，加偏移量计算物理地址。**

表面上看，好像使用二级页表让内存占用空间更大了。但由于**局部性原理** 实际是减少物理内存的占用的。

---

↑怎么理解这句话？：**如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。**

假设只有20%的一级页表被用到了，页表占用的内存空间4kb(一级) + 20%*4MB = 0.804MB << 单级页表 4MB

后面可以创建多级页表进一步减少开销。

---

**快表（TLB，Translation Lookaside Buffer）**

页表在内存中，我们访问的效率比较低，我们把页表拿出来，放于高速缓存中（见上面的结构），提升效率。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2013.png)

直接将页号与快表页号比较，匹配成功，取块号+偏移量形成地址；匹配失败，访问主存页表，并同步到块表**（这个和Redis缓存相同）**

**基本分段存储管理方式**

把用户进程的地址空间，也按照**模块**进行划分。**分段的大小是不固定的。**不同的段是有不同属性的，用分段（Segmentation）的形式把这些段分离出来。

**分段机制下，虚拟地址和物理地址是如何映射的？**

分段机制下的虚拟地址 ： **段选择因子   段内偏移量**

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2014.png)

- **分页与分段方式对比**

共同点：分页与分段都是非连续的分配管理方式（分布在内存中不同的物理块上的）

不同点：1、**分页**是以**物理单位**为基础的划分，**分段**是以**逻辑单位**为基础的划分。

2、分页是**一维地址空间**，分段是**二维地址空间。**

3、分段更容易信息共享和保护。

**分段的缺点**

- **外部碎片的问题**：段是根据实际需求分配内存，所以有多少需求就分配多大的段，不会出现内部内存碎片。但是会出现外部碎片的问题。
- **内存交换的效率低。**

**段页式管理方式**

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2015.png)

**将分页和分段结合起来。先分段（先将程序划分为多个有逻辑意义的段），再分页（把每个段划分为多个页）**

---

- 1个进程 → 1个段表
- 1个段表项 → 1个页表**（1个段占用内存大小不固定，可能对应多个页，所以对应页表）**
- 1个页表 → 多个物理块

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2016.png)

中间用段页表来进行关联。

## **3.3 虚拟内存管理 （重要，实现方式也同样重要）**

**虚拟内存的概念：**具有**请求调入和置换功能**，**从逻辑上对内存容量加以扩充**的一种内存管理技术。

### 虚拟内存的作用（被问过）

1、虚拟内存**可以使得程序可以使用比实际物理内存更大的地址空间。**

2、**隔离进程：**由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的，进程也没有办法访问其他进程的页表，**所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。**

3、**提高内存使用的安全性**，页表里的的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等，在内存访问方面，操作系统提供了更好的安全性。

![Untitled](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/Untitled%204.png)

虚拟内存的特征：1、多次性：内存不能一次性装入，分多次，多态请求去调入。2、对换性：用户进程并不需要常驻内存的。程序不需要运行的时候可以从内存中将其移出。3、虚拟性： 从逻辑上来扩充整个的内存空间。

### 虚拟内存的实现方式

**1、请求分页存储管理  2、请求分段存储管理  3、请求段页式存储管理**

- **页表机制**

多增加了状态位P（是否在内存中）、访问字段A（一段时间内，页被访问的次数）、修改位M和外存地址

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2017.png)

- **缺页中断机构**

程序执行的过程中，程序需要从外存中调入，产生一个中断**（这个中断是由于缺页导致的）**

缺页中断属于内中断。(内中断（CPU内部，陷入、故障、终止）和外中断（CPU外部，I/O中断请求、人工干预）)

- **地址变换机构**

请求调页，判断是否存在内存。可能需要**页面置换**。新增/修改页表项。热点表项同步到快表。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/ca9ab720-2d07-46eb-8dc8-a143afa1483a.png)

### 页面分配策略

给内存分多少个页面。

调入页面的时机：1、预调页策略：**一次性调入若干相邻页面，多用于进程首次调入。**

2、请求调页策略：**运行时发现缺页时调入，I/O开销较大。**

### 虚拟内存的实际应用

**1、扩展可用内存：**虚拟内存通过将不常用的页换出到磁盘，使得系统可以运行比物理内存更大的程序。

**2、隔离进程地址空间：**每个进程拥有独立的虚拟地址空间，进程之间无法直接访问彼此的内存，提高了系统的安全性和稳定性。
**3、简化内存管理：**程序员无需关心物理内存的分配和释放，操作系统负责管理虚拟地址到物理地址的映射。

## 3.4 局部性原理

**局部性原理** 是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。

其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点

在分页机制中，**页表的作用是将虚拟地址转换为物理地址**，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：

- **时间局部性**：由于程序中存在一定的循环或者重复操作，因此会反复访问同一个页或一些特定的页，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。
- **空间局部性**：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此当访问某个页时，往往会顺带访问其相邻的一些页。为了利用空间局部性，分页机制中通常采用预取技术来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。

# 4.网络系统

## 4.1 I/O

### 定义

I/O（Input/Output，输入/输出）是计算机系统中用于数据传输的机制，I/O操作是指**程序与外部设备（如键盘、鼠标、显示器、硬盘、网络接口等）之间的数据交互过程。**

输入：输入是指从外部设备向计算机系统（通常是内存或处理器）传输数据的过程。

输出：输出是指从计算机系统向外部设备传输数据的过程。

### 为什么网络I/O会被阻塞？

网络I/O会被阻塞是因为在**进行网络数据传输**时，操作系统在等待数据的发送或接收完成之前，会将进程挂起，直到数据传输完成后才恢复进程执行。

### 大文件传输

大文件会产生问题：**进程实际上会阻塞在read方法调用，因为要等待磁盘数据的返回。**

在高并发的场景下，针对大文件的传输的方式，应该使用【异步I/O + 直接I/O】来代替零拷贝技术。

对于阻塞问题，可以用异步I/O来解决。

## 4.2 服务器处理并发请求有哪几种方式？

- **单线程web服务器方式：**web服务器一次处理一个请求，结束后读取并处理下一个请求，性能比较低，一次只能处理一个请求。
- **多进程/多线程web服务器：**web服务器生成多个进程或线程并行处理多个用户请求，进程或线程可以按需或事先生成。有的web服务器应用程序为每个用户请求生成一个单独的进程或线程来进行响应。（一旦并发请求数量过多时，多个同时运行的进程或线程将会消耗大量的系统资源）
- **I/O多路复用web服务器：**web服务器可以I/O多路复用，达到只用一个线程就能监听和处理多个客户端的I/O事件。
- **多路复用多线程web服务器：**将多进程和多路复用的功能结合起来形成的web服务器架构，其避免了让一个进程服务于过多的用户请求。

## **4.3 高性能网络模式：Reactor 和 Proactor**

网络模式类似于设计模式，主要是一个设计思想。**Reactor** 和 **Proactor** 是两种高性能网络编程模式，主要用于**处理高并发 I/O 操作。它们的设计目标是提高系统的吞吐量和响应速度，同时降低资源消耗。**

### Reactor 模式

Reactor模式：市面上常见的开源软件很多都采用了这个方案，比如 **Redis、Niginx、Netty （面试问题：redis、nginx、netty是依赖什么做的这么高性能 ？）**

Reactor模式是一种事件驱动的设计模式**【对事件反应】**

来了一个事件，Reactor就有相对应的反应/响应。即I/O多路复用监听事件，根据事件类型分配（Dispatch）给某个进程线程。

- **核心组件**

Reactor模式主要由 **Reactor** 和 **处理资源池** 这两个核心部分组成。它们俩负责的事：

**1、Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件;**

**2、处理资源池负责处理事件，如 read → 业务逻辑 → send；**

- **工作流程**

1、注册事件：应用程序将感兴趣的事件（如读、写）注册到 Reactor。
2、事件监听：Reactor 通过 Demultiplexer 监听事件。
3、事件分发：当事件发生时，Reactor 将事件分发给对应的 Handler。
4、事件处理：Handler 处理事件（如读取数据、发送数据）。

- **Reactor工作模式**

Reactor模式是灵活多变的，可以应对不同的业务场景：Reactor的数量可以只有一个，也可以有多个。处理资源池可以是单个进程\线程。（这里C语言一般对应进程，Java一般对应线程）

### 1、单Reactor 单进程/线程

进程里有 **Reactor、Acceptor、Handler** 这三个对象：

Reactor 对象的作用是监听和分发事件，Acceptor 对象的作用是获取连接，Handler 对象的作用是处理业务

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2018.png)

**单Reactor\单进程 介绍**

- Step1、Reactor对象通过**select（IO多路复用接口）**监听事件，收到事件后通过dispatch进行分发，具体分发给Acceptor对象还是Handler对象，还要看收到的事件类型；
- Step2、**如果是连接建立事件，则交给Acceptor对象进行处理**，Acceptor对象通过accept方法获取连接，并创建一个Handler对象来进行响应，**如果不是连接建立事件，则交由当前连接对应的Handler对象来进行响应。**
- Step3、Handler对象通过read → 业务处理 → send 的流程来完成完整的业务流程。

### 2、单Reactor 多线程/多进程

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2019.png)

**基本流程**

step1、step2和step3与单Reactor单线程方案是一样的。接下来的步骤就不一样了：

**Handler对象不再负责业务处理，只负责数据的接收和发送**，Handler对象通过read读取到数据后**，会将数据发送给子线程里的Processor对象进行业务处理。**处理完成后会将结果发给主线程中的Handler对象。

**优点：能够充分利用多核CPU性能**

**缺点：同时带来了线程安全问题需要处理**

### 3、多Reactor 多进程/线程

Nginx也采用了这个东西。

**主线程中MainReactor,子线程中SubReactor。**主线程和子线程分工明确，**主线程只接收新连接，子线程负责完成后续的业务处理。**子线程和主线程的交互很简单，主线程只需要把新连接传给子线程，子线程无需返回数据。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2020.png)

### **Proactor 模式**

Reactor是**非阻塞同步网络模式**，感知的是**就绪可读事件**。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用read方法来完成数据的读取，也就是要应用进程主动将socket接收缓存中的数据读到应用程序中，这个过程是同步的，读取完数据后，应用进程才能处理数据。

Proactor是**异步网络模式。**感知的是**已完成的读写事件**。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成。

这里的读写工作全程由操作系统来做，并不需要像Reactor那样还需要应用进程主动发起 read/write 来读写数据，**操作系统完成读写工作后，就会通知应用进程直接处理数据。**

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2021.png)

- **核心组件**

Proactor：负责发起异步 I/O 操作并处理完成事件。
Completion Handler：处理 I/O 操作完成后的回调。
Asynchronous Operation Processor：执行实际的异步 I/O 操作（通常由操作系统提供）。

- **工作流程**

1、发起异步操作：应用程序发起异步 I/O 操作（如异步读、写）。
2、操作系统处理：操作系统执行 I/O 操作，完成后通知 Proactor。
3、事件分发：**Proactor 将完成事件分发给对应的 Completion Handler。**
4、事件处理：Completion Handler 处理完成事件（如处理读取的数据）。

总结：Reactor可以理解为**【来了事件，操作系统通知应用进程，让应用进程来处理】**，而Proactor可以理解为**【来了事件，操作系统来处理，处理完再通知应用进程】。**

# 5 文件管理

文件系统主要负责管理和组织计算机存储设备上的文件和目录（文件、目录的增删改查、访问控制）

## 5.1 文件系统基础

**1、文件的概念**

- 定义：以**计算机硬盘为载体**的存储在计算机上的信息集合（不只是硬盘，内存和一些缓冲区中也有文件）。
- 属性：（文件不单单记录信息，还有属性）描述文件状态的一组信息，比如名称、标识符、类型、大小、位置、保护、时间、日期和用户标识等。
- 基本操作：创建文件；读文件；写文件；文件重定位（寻址）；删除文件；截断文件；**打开与关闭**

**2、文件的结构**

文件的**逻辑结构**

- 无结构文件（流式文件）：以Byte为单位，没有具体结构，采用穷举方式搜索
- 有结构文件（记录式文件）：顺序文件、索引文件、索引顺序文件、直接文件或散列文件（Hash File）

文件的**物理结构**

- 文件的**目录结构：文件控制块（FCB）**： 基本信息、存取控制信息、使用信息
- 索引节点
- 目录结构（树型结构）

**3、文件的共享和保护**

- 文件共享

**硬连接（索引节点）**

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2022.png)

**软连接（符号链） 创建一个快捷方式**

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2023.png)

- 文件保护（保护文件不能随便被外界访问）

1、口令保护

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2024.png)

2、加密保护

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2025.png)

3、访问控制

针对不同用户，每一个用户对文件的读写操作是不一样的。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2026.png)

## 6.2 文件系统实现

### 文件系统的层次结构

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2027.png)

### 目录实现

- 线性列表

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2028.png)

- 哈希表

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2029.png)

### 文件实现

- **文件分配方式（文件的存储方式）**

**1、连续分配**

文件分配到磁盘上，所占用的盘块是连续的。**支持顺序和直接访问，速度快；不方便扩展，会产生磁盘碎片。**

连续分配的话，文件的读写效率很高。

**2、连接分配**

盘块和盘块之间用链接来进行关联。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2030.png)

**支持顺序访问，方便扩展，没有碎片；不支持直接访问，效率低。**

**3、索引分配**

给所有的盘块建立索引表，其实它的本质就是一个数组。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2031.png)

但是一个索引表存储的块是有限的，多个索引块进行连接方可以存更多的文件。也可以用混合索引来实现，既可以是实际的地址，也可以是二级索引表。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2032.png)

- **文件存储空间管理 →** 没有使用的空间(空闲空间的管理)。

将物理磁盘划分成一个个文件卷，也叫逻辑卷，逻辑盘。**每一个卷分成两大部分：目录区和文件区**

目录区：存放文件目录信息（FCB）、磁盘空间管理信息。

文件区：存放文件数据。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2033.png)

1、空闲表法

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/image%2034.png)

空闲盘块表，将连续的空闲块放在一起。 

2、空闲链表法

不用数组，用链表结构来表示。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/94bc2710-2cf7-41ef-87ed-835b4540e62c.png)

空闲表和空闲链表实现都比较简单，但都不太适合大型的文件系统。

3、成组链接法

成组链接法主要的目的是减少内存空间的占用。

将所有的空闲盘块按固定大小，固定数量去进行分组。每个组的大小是固定的，组是一个先进后出的栈结构。我们在第一个板块去记录后一个分组的一些信息。

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/9435b514-827c-4940-83fb-4f5e5fdd33ee.png)

**超级块：**一般情况下，我们会把**第一个分组中的信息**拷贝到超级块里面，当操作系统启动时，我们把这个超级块里面的信息给它加载进来。

4、位示图法  （高效，快速）

位示图(i,j)：用二进制位表示盘块的使用情况。

**分配过程：**1、顺序扫描位示图，找出符合需要的0；2、将找到的二进制位转换成盘号b：b = n*i + j

3、修改位示图，令map[i,j] = 1

**回收过程：**1、将盘块号转换成行号和列号：i = b/n, j = b%n 2、修改位示图，令map[i,j] = 0

![image.png](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20df0f210a6516464fba5eaa76e762de2d/c24d5da7-0789-4ab7-81e5-1bd5c11056d5.png)