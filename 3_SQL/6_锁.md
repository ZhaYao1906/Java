# 锁

# 1. 锁的种类

MySQL中的锁，根据粒度大小分为三种：全局锁、表级锁、行锁。

## 1、全局锁

执行后，整个数据库都处于只读状态。通过flush tables with read lock 语句会将整个数据库就处于只读状态。全局锁主要应用于**全库逻辑备份。**

## 2、表级锁

### 2.1 表锁

表锁是直接用显式的命令去判断。

```sql
lock tables t_student read;//表级别的共享锁，也就是读锁
lock tables t_stuent write;//表级别的独占锁，也就是写锁
```

### 2.2 元数据锁（MDL）→ 不需要显式使用，自动添加。

不需要显示的使用 MDL，因为当我们 **对数据库表进行操作时，会自动给这个表加上 MDL：**

对一张表进行 **CRUD 操作** 时，加的是 **MDL 读锁**；对一张表做 **结构变更操作** 的时候，加的是 **MDL 写锁**；

MDL 是为了保证当用户对表执行 CRUD 操作时，**防止其他线程对这个表结构做了变更。**

1、当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。

2、当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。

MDL 是在事务提交后才会释放，这意味着**事务执行期间，MDL 是一直持有的。**

### 2.3 意向锁

(就是加行锁之前先加表锁)**意向锁的目的是为了快速判断表里是否有记录被加锁**。

在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。**

### 2.4 **AUTO-INC 锁**

AUTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放**。
表里的主键通常都会设置成自增的，这是通过对主键字段声明 `AUTO_INCREMENT` 属性实现的。

## 3、行级锁

**RR（Repeatable Read）和 RC（Read Committed）**

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。

普通的 select 语句是不会对记录加锁的，因为它属于快照读如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为**锁定读**。

```sql
select ... lock in share mode;//对读取的记录加共享锁
select ... for update;//对读取的记录加独占锁
```

行级锁的类型主要有三类：
1、**Record Lock，记录锁**，也就是仅仅把一条记录锁上。（RR、RC隔离级别都是支持的）

记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：

2、**Gap Lock，间隙锁，**锁定一个范围，但是不包含记录本身。（只有RR隔离级别支持）

Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

**3、Next-Key Lock：Record Lock + Gap Lock 的组合，**锁定一个范围，并且锁定记录本身。（RR隔离级别）

Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。**next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。

**4、插入意向锁**

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻）

**//间隙锁和临键锁都是为了解决幻读问题而出现的**

# 2. 当前读 和 快照读

快照读：和MVCC相关，无任何锁的东西   select * from 

当前读：**当前读中执行的SQL语句，都会加锁**

当前读是数据库系统中的一种读取机制，指的是读取最新已提交版本，与快照读不同，当前读会获取记录的最新值，包括其他事务已提交的修改。

```sql
-- 当前读示例：会读取最新的已提交数据并加排他锁
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
```

# 3. 加锁详解

## 3.1 Record Lock

Record Lock 称为记录锁，锁住的是一条记录。而且**记录锁是有 S 锁和 X 锁**之分的：1、当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;

2、当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）；

## 3.2 Gap Lock

Gap Lock 称为间隙锁，**只存在于可重复读隔离级别**，目的是为了解决可重复读隔离级别下幻读的现象。**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。

表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了

![image.png](%E9%94%81%20105e745001648076be00dbe7c1dcf3c6/image.png)

## 3.3 Next-Key Lock

Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，**锁定一个范围，并且锁定记录本身。**

假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改和删除 id = 5 这条记录。

![image.png](%E9%94%81%20105e745001648076be00dbe7c1dcf3c6/image%201.png)

## MySQL是怎么加行级锁的（重要）

**加锁的对象是索引，加锁的基本单位是next-key lock，它是由记录锁和间隙锁组合而成的。**

但是，一些场景下，next-key lock**会退化**成记录锁或间隙锁。**（在能使用记录锁或者间隙锁就能避免幻读现象的场景下）**

### **情况一：唯一索引等值查询**

当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：

- 当**查询的记录是「存在」的**，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会**退化成「记录锁」**。
- 当**查询的记录是「不存在」的**，在索引树找到**第一条大于该查询记录的记录后**，将该记录的索引中的 next-key lock 会**退化成「间隙锁」**。

### **情况二：唯一索引范围查询**

**会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁**：

- 针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果**等值查询的记录是存在于表中**，那么该记录的索引中的 **next-key 锁会退化成记录锁。**
- 针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：当条件值的记录**不在表中，**那么不管是「小于」还是「小于等于」条件的范围查询**扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁**
- 当条件值的记录在表中，如果是「小于」条件的范围查询，**扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁**，

### **情况三：非唯一索引等值查询**

**因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁**。
当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是**非唯一索引等值查询的过程是一个扫描的过程直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁**。
当查询的记录「不存在」时，**扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁**。

### **情况四：非唯一索引范围查询**

非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于**非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况**，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。

### **情况五：没有加索引的查询**

**扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞**。

全表扫描相当于把表都锁住了，应当尽量避免这个问题。

---

总结

select * where id ≥ 4

加锁：4的行级锁、8的临键锁、8→+无穷的临键锁

其实也就是把id ≥ 4的范围给锁住，防止在该范围内插入幻影数据，造成幻读。

---

# 3. 数据库的表锁和行锁有什么用？

**表锁的作用：**

1、整体控制：表锁可以用来控制整个表的并发访问，当一个事务获取了表锁时，其他事务无法对该表进行任何的读写操作，从而确保数据的完整性和一致性。

2、粒度大：表锁的粒度比较大，在锁定表的情况下，可能会影响到整个表的其他操作

3、适用于大批量操作：表锁适合于需要大批量操作表中的数据的场景

**行锁的作用：**

1、细粒度控制：行锁可以精确控制对表中某行数据的访问，使得其他事务可以同时访问表中的其他行数据

2、减少锁冲突

**3、适用于频繁单行操作。**

# 4.乐观锁与悲观锁

悲观锁：**假设冲突频繁，**默认认为并发操作一定会发生冲突，因此 **提前加锁**，**确保同一时间只有一个线程/事务能访问资源。**

乐观锁：**假设冲突较少，**默认认为并发操作不会冲突，因此 **不加锁**，只在提交时检查数据是否被修改。

### 使用场景

**悲观锁适用场景**：需要强一致性（如支付系统）。业务逻辑复杂，操作耗时较长。并发冲突概率 > 50%。

**乐观锁适用场景**：高并发读操作（如热点商品详情页）。冲突概率 < 20%。能接受重试或降级处理。

### 数据库中的锁

**悲观锁**：通过**分布式锁实现**（如 Redis 的 `SETNX`、Zookeeper 临时节点）。

**乐观锁**：通过**版本号**（如 ETag）或**条件更新**（如 Cassandra 的轻量级事务）。