# 基本语法与知识

# 1. 数据库基础知识

## 1.1 数据库范式

数据库范式有 3 种：

### **1NF(第一范式)**

属性不可再分。也就是这个**字段只能是一个值，** 不能再分为多个其他的字段了。**1NF 是所有关系型数据库的最基本要求 ，** 也就是说关系型数据库中创建的表一定满足第一范式。

---

**举例：**

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image.png)

“家庭信息”和“学校信息”列均不满足原子性的要求，故不满足第一范式，调整如下：

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%201.png)

调整后的每一列都是不可再分的，因此满足第一范式。

---

### **2NF(第二范式)**

**消除了非主属性对于码的部分函数依赖**。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，**这个列称为主键，非主属性都依赖于主键。**

第二范式需要**确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）** 

![Untitled](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/Untitled.png)

### **3NF(第三范式)**

3NF **在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。**

**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**

---

举例：

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%202.png)

上表中，所有属性都完全依赖于学号，所以满足第二范式。但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，而不是主键“学号”，所以需要做如下调整：

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%203.png)

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%204.png)

符合 3NF 要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。

### 总结：

1NF : 属性不可再分。也就是这个**字段只能是一个值**，不能再分为多个其他的字段了。

2NF : 第二范式需要 **确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）**

3NF:**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**

### 第三范式相比第二范式的优点？

- **进一步减少数据冗余**
- **提高数据一致性**
- **减少更新异常**

### 扩展

- **巴斯-科德范式（BCNF）**

在满足3NF的基础上，**所有函数依赖的左部必须是超键**（即**不存在任何非主属性对候选键的部分或传递依赖**，**且主属性也不能依赖于非键属性**）。

- **第四范式**

在满足BCNF的基础上，**消除多值依赖**（即一个字段的多个值不能依赖于另一个字段的多个值）

例：

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%205.png)

- **第五范式**

在满足4NF的基础上，**消除连接依赖**（即**表不能通过多个较小表的连接重建**，除非这些表是原始表的投影）。

## 1.2 主键和外键有什么区别？

• **主键(主码)**：主键用于**唯一标识**一个元组，不能有重复，不允许为空。**一个表只能有一个主键。**

• **外键(外码)**：外键用来**和其他表建立联系用，** 外键是另一表的主键，**外键是可以有重复的，可以是空值。一个表可以有多个外键。**

外键约束：外键约束的作用是维护**表与表之间的关系**，确保数据的完整性和一致性。

## 1.3 SQL与NoSQL

**1、SQL** 是一种**结构化查询语言（Structured Query Language）**,专门用来和数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。

**2、NoSQL（Not Only SQL 的缩写）** 泛指 **非关系型的数据库**，主要针对的是**键值、文档以及图形类型**数据存储。**NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。**

**一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。**

NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。

![Untitled](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/Untitled%201.png)

### SQL vs NoSQL

1、ACID vs BASE 关系型数据库支持ACID即**原子性，一致性，隔离性和持续性**。相对而言，NoSQL采用更宽松的模型BASE，即**基本可用，软状态和最终一致性。**

2、扩展性

NoSQL数据之间无关系，这样就非常容易扩展，redis自带主从复制模式、哨兵模式、切片集群模式

关系型数据库的数据存在关联性，水平扩展较难，需要解决跨服务器JOIN，分布式事务等问题。

### 数据量多大的时候用Redis，数据量多大的时候用MySQL

Redis 的适用场景 ：**数据量较小（GB 级以内）。**

MySQL 的适用场景 ：**数据量较大（TB 级或更多）**

## 1.4 字符集的层次级别

MySQL 中的字符集有以下的层次级别：

- `server`（MySQL 实例级别）

不同版本的 MySQL 其 `server` 级别的字符集默认值不同，在 MySQL5.7 中，其默认值是 `latin1` ；在 MySQL8.0 中，其默认值是 `utf8mb4` 。

- `database`（库级别）

`database` 级别的字符集是我们在创建数据库和修改数据库时指定的。

- `table`（表级别）

`table` 级别的字符集是在创建表和修改表时指定的。

- `column`（字段级别）

`column` 级别的字符集同样是在创建表和修改表时指定的，只不过它是定义在列中。

它们的优先级可以简单的认为是 **从上往下依次增大，** 也即 `column` 的优先级会大于 `table` 等其余层次的。**如指定 MySQL 实例级别字符集是`utf8mb4`，指定某个表字符集是`latin1`，那么这个表的所有字段如果不指定的话，编码就是`latin1`。**

## 1.5 SQL分类

### 1 数据定义语言 DDL

数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。

DDL 的主要功能是**定义数据库对象**。**DDL 的核心指令是 `CREATE`、`ALTER`、`DROP`。**

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/abce617e-673c-470f-b67e-ebe4ad9a5f1c.png)

### **2 数据操作语言 DML**

数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。

DML 的主要功能是 **访问数据**，因此其语法都是以**读写数据库**为主。

DML 的核心指令是 `INSERT`、`UPDATE`、`DELETE`、`SELECT` 

### 3 事务控制语言 TCL

事务控制语言 (Transaction Control Language, TCL) 用于**管理数据库中的事务**。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。

TCL 的核心指令是 `COMMIT`、`ROLLBACK`。

### 4 数据控制语言 DCL

数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。

DCL 的核心指令是 `GRANT`、`REVOKE`。

**权限控制**

要授予用户帐户权限，可以用`GRANT`命令。

```sql
GRANT privilege,[privilege],.. ON privilege_level
TO user [IDENTIFIED BY password]
[REQUIRE tsl_option]
[WITH [GRANT_OPTION | resource_option]];
```

注：1. 在`GRANT`关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。

2.`ON privilege_level` 确定**权限应用级别**。MySQL 支持 global（`*.*`），database（`database.*`），table（`database.table`）和列级别。

3.`user` 是要授予权限的用户。如果用户已存在，则`GRANT`语句将修改其权限。否则，`GRANT`语句将创建一个新用户。可选子句`IDENTIFIED BY`允许您为用户设置新的密码。

4. `REQUIRE tsl_option`指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。

5.可选 `WITH GRANT OPTION` 子句允许您授予其他用户或从其他用户中删除您拥有的权限。
要撤销用户的权限，可以用`REVOKE`命令。

```sql
REVOKE   privilege_type [(column_list)]
        [, priv_type [(column_list)]]...
ON [object_type] privilege_level
FROM user [, user]...
```

注：1.在 `REVOKE` 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。

2.指定在 `ON` 子句中撤销特权的特权级别。

3.指定要撤消 `FROM` 子句中的权限的用户帐户。

## 1.6 触发器

触发器是一种与**表操作**有关的数据库对象，当触发器所在表上**出现指定事件时**，将调用该对象，**即表的操作事件触发表上的触发器的执行。**

**我们可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。**

### 触发器优缺点

触发器的优点：

- SQL 触发器提供了另一种检查数据完整性的方法。
- SQL 触发器可以捕获数据库层中业务逻辑中的错误。
- SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。
- SQL 触发器对于审计表中数据的更改非常有用。

触发器的缺点：

- SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，[ASP.NETopen in new window](http://asp.net/)，Perl）在服务器端验证用户的输入。
- 从客户端应用程序调用和 **执行 SQL 触发器是不可见的**，因此很难弄清楚数据库层中发生了什么。
- SQL 触发器可能会 **增加数据库服务器的开销。**

**MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。**

### 创建触发器

```sql
CREATE TRIGGER trigger_name #触发器名
trigger_time #触发器的触发时机。取值为 BEFORE 或 AFTER
trigger_event #触发器的监听事件。取值为 INSERT、UPDATE 或 DELETE。
ON table_name # 触发器的监听目标。指定在哪张表上建立触发器。
FOR EACH ROW # 行级监视，Mysql 固定写法，其他 DBMS 不同。
BEGIN
  trigger_statements #trigger_statements: 触发器执行动作。是一条或多条 SQL 语句的列表。
										 #列表内的每条语句都必须用分号 ; 来结尾。
END;
#当触发器的触发条件满足时，将会执行 BEGIN 和 END 之间的触发器执行动作。
```

## 1.7 数据库系统相关概念

- **数据库（DB）**：长期存储在计算机内，有组织，可共享的大量数据的集合。数据库中的数据按照一定的数据模型组织、描述和存储。
- **数据库管理系统（DBMS）**：位于用户和操作系统间的数据管理系统的一层数据管理软件。
- **数据库系统（DBS）**：在计算机系统中引入数据库后的系统。

**DBS包括DB和DBMS，DBS的核心是DBMS**

- **元组：** 关系数据库的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组。
- **候选码 ：** 若关系中某一属性或属性组的值能 **唯一的标识** 一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。
- **主码** : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。
- **外码** : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。

## 1.8 ER图

数据库设计需要通过ER图，**ER 图** 全称是 Entity Relationship Diagram **（实体联系图）**，提供了表示实体类型、属性和联系的方法。

例：学生选课的ER图

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%206.png)

# 2.数据库基本语法

## 2.1 左连接、交叉连接、内连接

### 2.1.1 左连接

**left join  左(外)连接，左表(a_table)的记录将会全部表示出来**，而右表(b_table)只会显示符合搜索条件的记录。**右表记录不足的地方均为NULL。**

![Untitled](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/362020a4-9dee-4844-ba25-f2338b40eb39.png)

例：表A 数据 B C        表B 数据 B D

返回 数据B C

### 2.1.2 右连接

right join 它的全称是右外连接，是外连接中的一种。与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。**左表记录不足的地方均为NULL。**

![Untitled](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/0e368c38-60c0-4c8e-9dfc-a384a50daacc.png)

### 2.1.3 内连接

`A JOIN B` 默认情况下是一个内连接（Inner Join）。内连接返回的是两个表中满足连接条件的所有行。只有在两个表中都存在匹配的数据时，才会返回这些数据行。**如果某行在表A中存在而在表B中不存在，或者在表B中存在而在表A中不存在，这些行将不会包含在结果集中。**

![Untitled](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/6c2e4a1f-68a5-4b1e-b5c4-ec38f39a96c6.png)

### 2.1.4 交叉连接（cross join）

它们都返回被连接的两个表所有数据行的[笛卡尔积](https://so.csdn.net/so/search?q=%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF&spm=1001.2101.3001.7020)，返回到的**数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。**

```sql

**SELECT <字段名> FROM <表1> CROSS JOIN <表2> [WHERE子句]**
SELECT <字段名> FROM <表1>, <表2> [WHERE子句] 
#以上两个句子是等价的
```

例如，有 A 和 B 两个集合，它们的值如下：A = {1,2}    B = {3,4,5}

A cross B : A×B={(1,3), (1,4), (1,5), (2,3), (2,4), (2,5) };

## 2.2 **drop**、delete 与 **truncate** 区别？

**drop直接将表都删除掉，truncate只删除表中的数据**

**1.用法不同**

- **`drop`(丢弃数据)**:  `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
- **`truncate` (清空数据) :**  `truncate table 表名` ，**只删除表中的数据，** 再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- **`delete`（删除数据）** :  `delete from 表名 where 列名=值`，删除某一行的数据，如果不加 `where` 子句和`truncate table 表名`作用类似。

注：truncate和不带where子句的delete、以及drop都会删除表内的数据，但是truncate和delete只删除数据，不删除表的结构（定义），执行drop语句，此表的结构也会删除，也就是执行drop后对应的表不复存在。

**2.属于不同的数据库语言**

`truncate` 和 `drop` 属于 DDL(数据定义语言)语句 **，操作立即生效**，**原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。**

`delete` 语句是 DML (数据库操作语言)语句 **，这个操作会放到 rollback segment 中，事务提交之后才生效。**

---

注：DML 语句和 DDL 语句区别：

• **DML 是数据库操作语言（Data Manipulation Language）的缩写**，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。

• **DDL （Data Definition Language）是数据定义语言的缩写**，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。

## 2.3 NULL 和''的区别是什么？（为什么MySQL不建议用NULL作为列默认值）

`NULL` 跟 `''`(空字符串)是两个完全不一样的值 

**1、确定性：** `NULL` 代表一个不确定的值,就算是两个 `NULL`,它俩也不一定相等。

**2、占用空间：**`''`的**长度是 0，是不占用空间的**，而**`NULL` 是需要占用空间的。**

**3、对聚合函数的影响：** `NULL` 会影响聚合函数的结果。例如，**`SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。**

---

`COUNT` 的处理方式取决于参数的类型。

如果参数是 `*`(`COUNT(*)`)，则会统计所有的记录数，包括 `NULL` 值；

如果参数是某个字段名(`COUNT(列名)`)，则会忽略 `NULL` 值，只统计非空值的个数。

---

**4、比较运算符：查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULLl` 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。** 而`''`是可以使用这些比较运算符的。

## 2.4 MySQL字段类型

MySQL 字段类型可以简单分为三大类：数值类型、字符串类型、日期时间类型。

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%207.png)

### 整数类型的UNSIGNED属性

MySQL 中的整数类型可以使用可选的 **UNSIGNED 属性**来表示**不允许负值的无符号整数。** 使用 **UNSIGNED 属性可以将正整数的上限提高一倍**，因为它不需要存储负数值。

### DECIMAL和FLOAT/DOUBLE的区别是

DECIMAL 和 FLOAT 的区别是：**DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。**

**类似于Java中的BigDecimal和Float的区别。DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。**

### **DATETIME和TIMESTAMP的区别是什么？**

**DATETIME**

范围：1000-01-01 00:00:00 到 9999-12-31 23:59:59，用于存储日期和时间，不包含时区信息。

不会自动调整时间，**存储的是绝对时间。**

**TIMESTAMP**

插入时会自动根据服务器的时区设置转换为 UTC，**查询时会根据客户端的时区设置转换回本地时间。可以设置为自动更新为当前时间戳。**

stamp : 邮票。

### Boolean如何表示

MySQL中没有专门的布尔类型，而是用TINYINT(1)来表示布尔值。可以存储0或1，分别对应false或true。

## 2.5 MySQL的关键字in和exist（仔细看看！）

IN 和 EXISTS 都是用来**处理子查询的关键词。**

**当使用IN时，类似于嵌套循环。** 数据库会先执行子查询（如果有的话），获取子查询的结果集，将其存储在内存或者临时表中。然后对于主查询的每一行数据，数据库会遍历子查询的结果集，检查主查询的当前值是否在子查询的结果集中。

**EXIST使用的是一种关联子查询的执行方式**，数据库会对主查询的每一行数据，执行一次子查询。一旦子查询找到一条满足条件的数据就会立即停止查询。

**IN关键字：**

IN 用于检查**左边的表达式是否存在于右边的列表或子查询的结果集中。** 如果存在，则 IN 返回TRUE，否则返回FALSE

**EXIST关键字：**

EXISTS 用于**判断子查询是否至少返回一行数据。** 它不关心子查询返回什么数据，只关心是否有结果。如果子查询有结果，则EXIST返回TRUE，否则返回FALSE。

### 区别与选择

- 性能差异：**EXISTS的性能优于IN**，特别是当子查询的表很大时，因为**EXISTS一旦找到匹配项就会立即停止查询。**
- **NULL值处理：** IN 能够正确处理子查询中包含NULL值的情况，而EXISTS不受子查询结果中的NULL值影响，因为它关注的是行的存在性，而不是具体值。
- IN适合子查询结果集很小的情况，EXIST适合处理大数据量和需要判断关联关系的场景。

## 2.6 MySQL中的count(*)、count(1)、count(字段名)有什么区别？

count()都用于 **统计行数**。

- **COUNT(*)：** 统计表中满足条件的行数，**包括所有列，即使某些列的值为 NULL。**
- **COUNT(1)**：COUNT(1) 中的 1 是一个常量值，MySQL 会忽略它，直接统计行数。与 COUNT(*) 的行为几乎相同。
- **COUNT(字段名)：**统计**指定字段中非 NULL 值**的行数。

## 2.7 UNION和UNION ALL的区别和作用？

两者的主要作用都是**将多个SELECT语句的结果集合合并成一个结果集。** 一般要求参与合并的各个SELECT语句的列数、列的顺序以及对应列的数据类型都要保持一致。

**两者区别：**

1、去重处理：**UNION 会自动去除合并结果集的重复行，UNION ALL不会进行去重操作**，它会保留所有行，包括重复行。

2、性能：由于去重处理，UNION ALL的性能会比UNION高很多。

# 3. MySQL常见搜索引擎及区别

## 3.1 InnoDB

1、支持事务

2、默认锁的颗粒度是行级锁，可以支持更高的并发；也支持表级锁

3、支持**外键约束**，**外键约束其实降低了表的查询速度，增加了表之间的耦合度**

## 3.2 MyISAM

1、不提供事务支持

2、支持表级锁

3、不支持外键

**适用于那些只需要进行查询，而对事务控制没有要求的**

## 3.3 memory

**把数据存在内存中**，适用于对性能要求比较高的读操作，但是在服务器重启或崩溃时数据会丢失，它不支持事务、行级锁和外键约束。

![屏幕截图 2025-02-10 152824.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/5353def6-91de-423f-8a76-5cec50b57ddd.png)

# 4. MySQL建表时应该注意什么？

1、注意**选择合适的存储引擎**，如果要支持事务选择InnoDB。

2、注意**字段类型的选择**，对于日期类型要选择datetime，只记录年月日使用date类型。

对于字符串的选择，固定长度字段选择char，不固定长度字段选择varchar。

3、主键**字段选择自然主键，** 不要有业务意义。建议使用int unsigned类型，特殊场景使用bigint类型。

# 5. MySQL 执行一条查询语句

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%208.png)

**Server 层负责建立连接、分析和执行 SQL**。**存储引擎层负责数据的存储和提取**

Step1、**连接器：在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句。**

**Step2、查询缓存：** 连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，如果 SQL 是查询语句（select 语句）MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的。

查询缓存的命中率很低的，MySQL 8.0 版本直接将查询缓存删掉了。

**Step3、解析SQL：词法分析**。MySQL 会根据你输入的字符串识别出关键字出来。**语法分析**。根据词法分析的结果，语法解析器会根据语法规则，**构建语法树。**

**Step4、执行SQL：**

• prepare 阶段，也就是预处理阶段：

1、**检查 SQL 查询语句中的表或者字段是否存在**；

2、**将 `select *` 中的 `*` 符号，扩展为表上的所有列**；

• optimize 阶段，也就是优化阶段；

• execute 阶段，也就是执行阶段；

# 6. MySQL的存储

MySQL中的数据一般都是存在磁盘下的，具体**表现形式因存储引擎而异**，接下来讨论的范畴都是基于InnoDB的

## 6.1 存储的文件形式（重要）

在database文件夹下、共有三个文件。

- **db.opt，** 用来存储当前数据库的默认字符集和字符校验规则。
- **t_order.frm** ，t_order 的**表结构**会保存在这个文件。
- **t_order.ibd，** t_order 的**表数据**会保存在这个文件。

### 表空间的文件结构

**表空间由段（segment）、区（extent）、页（page）、行（row）组成**，InnoDB存储引擎的逻辑存储结构大致如下图：

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%209.png)

**页 ：InnoDB 的数据是按「页」为单位来读写的**，**默认每个页的大小为 16KB。**

**区**：**InnoDB 存储引擎是用 B+ 树来组织数据的。** 让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了。

**在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。**

**段：表空间是由各个段（segment）组成的**，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。

---

索引段：存放 B + 树的非叶子节点的区的集合；

数据段：存放 B + 树的叶子节点的区的集合;

回滚段：存放的是回滚数据的区的集合;

---

## 6.2 InnoDB 行格式 — COMPACT

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%2010.png)

### 记录额外信息

包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息

### 变长字段长度列表

在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。

变长字段会按照列的顺序**逆序存放。**

逆序存放的原因：主要是因为「记录头信息」中指向下一个记录的指针,指向的是下一条记录的「记录头信息」和「真实数据」之间的位置。这样的好处是向左读就是记录头信息，向右读就是真实数据,比较方便。

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%2011.png)

### NULL值列表

Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中,如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序**逆序排列。**
二进制位的值为`1`时，代表该列的值为NULL。

二进制位的值为`0`时，代表该列的值不为NULL。

---

NULL 值列表也不是必须的。**当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**。

### 记录头信息

记录头信息中包含的内容很多，比如标记**此行有没有被删除、下一条记录的位置、表示当前记录的类型。**

## 6.3 varchar(n)中n的最大值是多少？

一行记录最大只能存储 65535 字节的数据。**其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的**。

**在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532。
在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。**

**多字段的情况下，额外考虑了**

---

**char(n)** : 固定长度的字符串，即使存储的字符串长度小于定义的长度，MySQL也会在字符串的末尾填充空格以达到指定长度。

---

## 6.4 行溢出后，MySQL是怎么处理的？

**发生行溢出，多的数据就会存到另外的「溢出页」中**。

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%2012.png)

# 7. SQL慢查询排查

慢查询排查是数据库性能优化的重要环节

## Step1 定位慢查询

### 1、开启慢查询日志

**启用慢查询日志：在数据库中 启用慢查询日志（slow_query_log），记录执行时间超过指定阈值的查询。**

在配置文件中设置

```sql
slow_query_log = ON
long_query_time = 2  # 记录执行时间超过 2 秒的查询
```

会以慢查询记录的形式显示出来，包括执行时间，慢查询的语句等

**监控实时性能：** 数据库内置工具

```sql
-- 查看当前运行中的SQL
SHOW PROCESSLIST;
-- 查看锁状态
SHOW ENGINE INNODB STATUS;
```

## Step2、 分析慢查询

**使用 `EXPLAIN` 或 `EXPLAIN ANALYZE`**：对慢查询使用 `EXPLAIN` 命令，可以查看执行计划，了解查询是如何被执行的。

关键字段：

![image.png](%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%9F%A5%E8%AF%86%20a5d42f38e5604ba6946d596b98013dcd/image%2013.png)

---

**all :** 全表扫描，逐行扫描整个表数据，性能最差

**index :** 遍历整个索引树（不扫描表数据），比All稍好但仍需扫描大量数据

**range :** 使用索引检索特定范围内的数据，性能较好

**ref :** 使用非唯一索引（或唯一索引的非唯一前缀）查找单值，性能优秀。

---

分析：1、索引问题：索引失效

2、SQL写法问题

3、数据量问题：**单表数据量过大，需分库分表。**

## Step3、优化手段

- **索引的有效性**：确认查询所需的索引是否存在。使用的字段是否可以利用现有索引，**考虑添加缺失的索引。**
- **SQL语句优化：** 避免 SELECT * / 明确指定字段。分页优化 / 使用WHERE + LIMIT替代OFFSET；
- **架构优化：** 读写分离：将请求分流到从库 / 分库分表：按业务拆分/缓存层：使用Redis缓存热点数据。

# 8. 其他问题

## 8.1 MySQL如何避免重复插入数据

### 方式一、使用UNIQUE约束

在表的相关列上添加UNIQUE约束，确保每个值在该列中唯一。

### 方式二、使用INSERT … ON DUPLICATE KEY UPDATE

这种语句允许在插入记录时处理重复键的情况。如果插入的记录与现有的记录冲突，可以**选择更新现有的记录。**

### 方式三、使用INSERT IGNORE

该语句会在插入记录时**忽略那些因重复键而导致的插入错误**

## 8.2 MySQL中的数据排序是怎么实现的？

数据排序是通过 **ORDER BY 子句**实现的。

排序的实现方式：

- **使用索引排序**

如果 ORDER BY 的列已经建立了索引，并且**索引的顺序与排序顺序一致（升序或降序），MySQL 可以直接利用索引的顺序返回结果**，而无需额外的排序操作。这种方式效率最高。

- **使用文件排序（FileSort）**

如果 ORDER BY 的列没有索引，或者索引的顺序与排序顺序不一致，MySQL 会使用文件排序（Filesort）对数据进行排序。

1、内存排序：**如果数据量较小**，排序完全在内存中完成。

2、磁盘排序：如果数据量较大，内存不足以容纳所有数据，**MySQL 会将数据分块排序，并将中间结果写入磁盘。** 最后通过 **归并排序（Merge Sort）** 将磁盘上的数据合并为最终结果。

## 8.3 MySQL中的深度分页

深度分页（Deep Pagination）是指在大数据量的表中，查询靠后的分页数据（例如第 1000 页、第 10000 页等）。深度分页会导致性能问题。

### LIMIT offset,size

工作原理：**MySQL 需要先扫描 offset + size 行数据**，然后跳过前 offset 行，返回剩下的 size 行。

LIMIT 10000, 10 需要扫描 10010 行数据，然后跳过前 10000 行，返回最后 10 行。

LIMIT 10的话，只需要扫描前10条数据返回即可。

### 解决方案

- **标签记录法**

**通过记录上一页最后一条记录的标识值（如主键ID），作为下一页查询的起点，避免扫描全部偏移量**

```sql
-- 第一页
SELECT * FROM users
ORDER BY id
LIMIT 10;

-- 第二页（使用上一页的最后一条记录的 id 作为游标）
SELECT * FROM users
WHERE id > 100  -- 假设上一页的最后一条记录的 id 是 100
ORDER BY id
LIMIT 10;
```

适用场景：

1、数据按唯一递增字段（如自增 ID、时间戳）排序  2、分页顺序固定，不允许跳页（如只能“上一页/下一页”导航）

- **基于游标的分页（Cursor-based Pagination）**

使用  **游标（通常是唯一且有序的列，如主键或时间戳）来替代 LIMIT offset, size，** 避免扫描大量数据。

游标分页的核心思想是通过上一页的最后一条记录的值来定位下一页的起始位置，而不是通过跳过行数。

数据库游标是一个数据库对象，**使得应用程序可以逐行访问查询结果集，而不仅仅一次性处理所有结果。它允许开发者在结果集中的行之间移动，方便进行复杂的数据操作，比如更新或删除特定的行。**

```sql
#查询第一页数据（假设每页显示 10 条记录）
SELECT * FROM orders ORDER BY order_id LIMIT 10;

#使用游标分页，从 order_id = 10 的下一条记录开始查询：
SELECT * FROM orders WHERE order_id > 10 ORDER BY order_id LIMIT 10;
```

缺点:需要客户端记录游标值。不支持直接跳转到指定页码。

- **使用覆盖索引（Covering Index）**

通过覆盖索引直接获取分页数据，**避免回表操作。**

```sql
-- 创建覆盖索引
CREATE INDEX idx_id_name ON users(id, name);
-- 使用覆盖索引查询
SELECT id, name FROM users
ORDER BY id
LIMIT 10000, 10;
```

- **子查询优化：使用索引优化，减少需要扫描的数据量**

```sql
-- 创建索引
CREATE INDEX idx_age ON users(age);
-- 利用限定条件，减少扫描的数据量
-- 优化后的查询
SELECT * FROM users
WHERE age > 18
ORDER BY id
LIMIT 10000, 10;
```
