# 索引

# 1. 索引的优缺点（考过）

**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。**

（如果问索引为什么能快速查询，则要结合数据结构来回答）

优点：

- 使用索引可以大大**加快数据的检索速度（大大减少检索的数据量）**, 这也是创建索引的最主要的原因。
- 通过创建**唯一性索引**，可以保证数据库**表中每一行数据的唯一性。**
- **优化排序和分组操作**

缺点：

- 创建索引和维护索引**需要耗费许多时间。**当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会**耗费一定空间。**
- **插入、更新和删除操作变慢**

如果数据库的数据量不大，不建议使用索引，因为不一定能带来查询速度的提升

# 2. 索引类型总结

- **按数据结构分**

**1、B+Tree 索引**：是 MySQL 默认存储引擎 InnoDB 采用索引数据结构，所有数据都存储在叶子节点中，非叶子节点只存储索引，提高范围查询的性能和减少磁盘IO开销，千万级的数据量 b+树的树高只需要 3 层。

**2、Full-Text 索引：全文索引用于对文本内容进行搜索，采用倒排索引等数据结构来实现全文搜索功能，支持关键字搜索和模糊查询**

**3、哈希索引**：哈希索引通过哈希函数计算键的存储位置，适用于等值查找，速度快但不支持范围查找。

- **按底层存储方式**

**1、聚簇索引（索引结构和数据一起存放，主键索引）** 

**2、非聚簇索引（索引结构和数据分开存放，二级索引）**

注：通常一张表只能有一个聚簇索引，但一张表可以有多个非聚簇索引。主键默认是聚簇索引，而非聚簇索引需要显式创建。聚簇索引的查询性能较高，非聚簇索引的查询性能较低（因为需要回表操作）

聚簇索引优点：1、**查询速度非常快** 2、**对排序查找和范围查找优化**

聚簇索引缺点：1、依赖有序的数据 2、更新代价大

非聚簇索引优点：更新代价比聚簇索引要小

非聚簇索引缺点：可能会二次查询（回表）

- **按「字段特性」分类**

**主键索引、唯一索引（ UNIQUE 字段）、普通索引、前缀索引（对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引）**

- **按「字段个数」分类**

**单列索引、联合索引**。

在创建表时，InnoDB 存储引擎会**根据不同的场景**选择不同的列作为索引：

1、如果有主键，默认会**使用主键**作为聚簇索引的索引键（key）；

2、如果没有主键，就选择**第一个不包含 NULL 值**的唯一列作为聚簇索引的索引键（key）；

3、在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增id列作为聚簇索引的索引键（key）；

## 2.1 存储在B+Tree的数据结构

B+Tree 是一种**多叉树**，**叶子节点才存放数据，非叶子节点只存放索引，** 而且**每个节点里的数据是按主键顺序存放的。**

每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，**并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。（下面图底层应该是双向链表）**

![image.png](%E7%B4%A2%E5%BC%95%2050ab5d3b25da4528a9ac967cce098683/image.png)

这个双向链表除了便于我们范围查询之外，由于**天然顺序排序**的方式：

**1. 高效的全表顺序扫描，** 直接遍历叶子节点链表，无需从根节点逐层查找，减少 I/O 次数。

**2.优化排序操作，** 双向链表允许从后向前遍历叶子节点，天然支持 ORDER BY ... DESC 的倒序查询

## 2.2 主键索引的B+Tree 和 二级索引的B+Tree

主键索引的 B+Tree 的叶子节点**存放的是实际数据**，所有完整的用户记录都存放在主键索引的B+Tree 的叶子节点里；

 二级索引的 B+Tree 的叶子节点存放的是**主键值，而不是实际数据**。 

## 2.3 为什么选择B+Tree这一数据结构

### **1、B+Tree vs B Tree**

**B树**

![image.png](%E7%B4%A2%E5%BC%95%2050ab5d3b25da4528a9ac967cce098683/9c991dd6-7c77-476a-a5d9-40297f3688a4.png)

例：在上图中一颗3阶的B树中要查找索引值是9的记录，那么步骤可以分为：

1、与根节点的索引（4，8）进行比较，9大于8，那么往右的子节点走

2、然后该子节点的索引为（10，12），因为9小于10，所以会往该节点的左边子节点走；

3、走到索引为9的节点，我们找到了索引值为9的节点。

- B树每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘I/O次数来读到 **【有用的索引数据】**

数据量相同的情况下，相比存储既存索引又存记录的B树，B+树的非叶子节点可以存放更多的索引，因此B+树可以比B树更【矮胖】，查询底层节点的磁盘I/O次数会更少。

- B+Tree 叶子节点采用的是**双链表连接**，**适合 MySQL 中常见的基于范围的顺序查找，**而 B 树无法做到这一点。

- **B+树的插入和删除效率更高。**

### **2、B+Tree vs 二叉树**

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为**`O(logdN)`** 即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，而二叉树的每个父节点的儿子节点个数只能是 2 个。

### **3、B+Tree vs Hash**

Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。但是 Hash 表不适合做范围查询，它更适合做等值的查询。

### 4.**平衡二叉查找树（AVL 树）**

主要是在二叉查找树的基础上增加了一些条件约束：**每个节点的左子树和右子树的高度差不能超过 1**。**不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率**。

### B+索引和哈希索引的区别

在创建哈希索引时，索引字段的值会通过哈希函数转换为一个哈希码，**哈希码作为键存储在哈希表中。**

哈希索引不支持范围查询 、**前缀匹配查询**（B+树索引支持）

空间占用：哈希索引的空间占用相对较少，B+树索引的空间占用相对较大，因此需要维护树的结构和指针。

插入和删除：哈希索引的**插入删除操作通常很快**，**B+树的插入删除需要考虑维护树的平衡。**

## 2.4 最左匹配原则（这个得结合例题）

最左匹配原则是指在数据库查询优化器处理SQL语句时，**优先使用索引最左边的列**进行匹配和过滤。**（联合索引包含多个列，那么查询条件必须从索引的最左边开始才能有效利用索引）**

---

联合索引是一种“多维”的数据结构，这里的“多维”是指 多个列的组合键在排序和检索中的层级关系。

在联合索引中，键的排序规则是逐列比较的：**先按A排序，A相同，则按B排序；A、B都相同，再按C排序。**

如果查询条件不满足最左匹配原则，即不包含索引的最左列，那么数据库引擎将无法利用索引的有序性，只能进行全表扫描。这会导致性能显著下降。

---

**总结：**

**联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。**

联合索引有一些特殊情况，**并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询**，可能存在部分字段用到联合索引的B+Tree，部分字段没有用到联合索引的B+Tree的情况。

case1、索引是(a,b,c)  查询条件：a = 1 and c = 3 and b = 2

a,b,c 都会用到索引，MySQL中的优化器会对其进行一个**重排序**的操作

case2、索引是(a,b,c)  查询条件：a = 1 and b > 2 and c = 3

a,b 会用到索引，首先按照a匹配,然后按照b范围查询（但是b的范围查询会导致索引无法继续使用c列）

case3、索引是(a,b,c)  查询条件：b = 2/c = 3/b = 2 and c =3

不符合最左匹配原则，无法匹配上联合索引。

case4、索引是(a,b,c)  查询条件:  a = 1 and c = 1
严格意义上来说属于索引截断，不同版本处理方式也不一样。MySQL5.5, 

前面的a会走索引。MySQL5.6以后会使用索引下推的功能。

case5、索引是(a,b,c)  查询条件：a ≥ 1 and b = 2

a,b都会用到索引，对于符合a = 1的二级索引记录的范围里，b字段的值是[有序]的。

case6、a between 2 and 8 and b = 2

a,b都用到了联合索引，**betweem..and在mysql中是 ≥ 和 ≤的意思**

## 2.5 MySQL中的回表是什么

回表（Back to Table） 是 MySQL 在执行查询时，**通过非聚簇索引（Secondary Index）查找到主键值后，** 还需要**根据主键值回到聚簇索引（Clustered Index）中查找完整数据行的过程。回表操作会增加额外的磁盘 I/O，从而影响查询性能。**

Step1、通过非聚簇索引查找主键值

Step2、通过主键值查找完整数据行

Step3、返回数据行

## 2.6 B+树中查询数据的全过程

### 查询数据

Step1、从根节点开始查找，逐层向下查找。根据查询条件 id = 3，在根节点中找到 2 <= 3 < 4，因此定位到中间子节点。

Step2、定位到叶子节点，在叶子节点中查找数据

Step3、返回查询结果。

### 范围查询

B+ 树的叶子节点通过指针连接成一个有序链表，因此范围查询非常高效。

Step1、定位起始位置：按照查询数据的方式定位叶子节点的起始位置。

Step2、遍历叶子节点链表，沿着叶子节点链表向后遍历。

Step3、返回查询结果。

# 3.覆盖索引

如果一个**索引包含（或者说覆盖）所有需要查询的字段的值**，我们就称之为 **覆盖索引（Covering Index）。**

非聚簇索引不一定回表查询，如果SQL查询的就是主键，那就会**直接返回，这种情况就称之为索引覆盖。**

无需回表，提升性能！！！

示例：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 主键，聚簇索引
    name VARCHAR(50),    -- 姓名
    age INT,             -- 年龄
    city VARCHAR(50)     -- 城市
);

-- 创建一个覆盖索引
-- 这个索引包含了 city、name 和 age 列。
CREATE INDEX idx_city_name_age ON users(city, name, age);

--优化后的查询
SELECT name, age FROM users WHERE city = 'Beijing';
```

# 4.索引下推

**索引下推（Index Condition Pushdown,ICP）**

定义：索引下推是一种优化策略，在索引扫描阶段 **提前应用部分查询条件** ，以减少数据访问的范围和次数。**提升查询效率！！！**

在执行查询时，数据库引擎首先使用索引扫描过滤掉**（在索引遍历的过程中，执行部分where子句的判断条件）**不符合条件的索引项，然后再访问数据表中的实际行，从而减少不必要的表扫描。

注意：**索引下推是应用在联合索引上的。提前在存储引擎层过滤，本该由Server层做操作，交由存储引擎层，因此叫做“下推”。**

除了可以减少回表次数之外，索引下推还可以减少存储引擎层和Server层的数据传输量。

### 适用场景

索引下推适用于那些具有复杂过滤条件的查询，特别是条件可以部分应用于索引扫描的场景。

- 多列组合索引。
- 使用范围查询或模糊匹配的查询。
- **复杂的WHERE条件，尤其是包含多个AND和OR的查询。**

# 5. 为什么加索引可以加快扫描范围

## 1、减少数据扫描量

索引通过创建有序的数据结构，使得 **数据库可以直接定位到范围的起始点和终止点，** 然后 **只扫描这两个点之间的数据，大大减少了扫描量** ，相比较全表扫描，显著提升了查询效率。

## 2、优化数据检索路径

数据库可以利用B+树的多级跳跃节点，迅速定位到目标数据行，而无需逐行扫描。

## 3、提高缓存命中率

# 6. 什么情况下走索引

**1. WHERE 子句中的条件（最常见的）** 简单条件、范围查询、LIKE 操作。

2. **ORDER BY 子句** 如果查询中有 **`ORDER BY` 子句** 并且排序的列上有索引，数据库可以使用索引来排序，从而避免全表扫描。
   
**3. JOIN 操作在 `JOIN` 操作中，** 如果连接条件的列上有索引，数据库会使用这些索引来快速匹配表之间的数据，从而提高联接的效率。

4. **使用聚合函数**对于如 `SUM()`, `COUNT()`, `AVG()` 等聚合函数，如果涉及的列有索引，数据库可以使用索引来加速计算过程。

## 什么时候不适合使用索引？

字段中存在大量重复数据，不需要创建索引；

表数据太少的时候，不需要创建索引；

经常更新的字段不用创建索引；

# 7. 怎么确定语句是否走了索引？—explain

通过 **explian**查看执行计划来确认，主要用来分析sql语句的执行过程，比如有没有走索引，有没有外部排序，有没有索引覆盖等等。

![Untitled](%E7%B4%A2%E5%BC%95%2050ab5d3b25da4528a9ac967cce098683/Untitled.png)

对于执行计划，参数有：

- **possible_keys 字段表示可能用到的索引；**
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- type 表示数据扫描类型，我们需要重点看这个。

**如果 typy=all，代表没有走索引，进行了全表扫描。如果 key 不为 null，说明用到了索引。**

# 8. 索引的使用

## 8.1给某个列添加索引

```sql
create index index_name on table_name(column_name)#index_name是你为索引指定的名称,table_name是你要添加索引的表名,column_name是你要添加索引的列名。
```

## 8.2 创建联合索引

```sql
CREATE INDEX index_product_no_name ON product(product_no, name);#联合索引(product_no, name) 
```

## 8.3 删除索引

```sql
ALTER TABLE user DROP INDEX user_idx;

```

# 9.索引失效

**1.使用左模糊匹配，或左右模糊匹配**

也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。

**2.对索引使用函数**

如果查询条件中对索引字段使用函数，就会导致索引失效。`select * from t_user where length(name)=6;` 

**3.对索引进行计算**

在查询条件中**对索引进行表达式计算**，也是无法走索引的。`select * from t_user where id + 1 = 10;` 要是id = 10 - 1；是没问题的。

**4.隐式类型转换（字符串 —> 数字）**

索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效; **MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。

注：**如果索引字段是字符串类型，但是在条件查询中，输入的参数是整形的话，你会在执行计划的结果发现这条语句会走全表扫描。**

**5.联合索引非最左匹配**

**6.where子句中的or条件**

如果**在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。**

# 10.其他问题

## 10.1 索引存在哪里？

InnoDB存储引擎，**表空间文件（.ibd）。InnoDB使用表空间文件来存储表的数据结构和索引，每个表通常有一个对应的.idb文件，这个文件包含了表的数据和索引。**

索引数据和表数据存储在同一个 `.ibd` 文件中，但它们在文件内部是分开存储的。

## 10.2 索引优化详细（考过）

**1、前缀索引优化**

使用前缀索引是为了 **减小索引字段大小，** 可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

**2、覆盖索引优化**

覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表操作。 

**3、主键索引最好是自增的**

使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。

每次**插入一条新记录，都是追加操作，不需要重新移动数据**，因此这种插入数据的方法效率非常高。

**4、防止索引失效。**
