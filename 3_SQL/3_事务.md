# 事务

# 1 基础知识

事务是由MySQL引擎来实现的，InnoDB支持事务，MyISAM不支持事务。

事务是数据库管理系统中的一个重要概念，它是由一组数据库操作组成的逻辑工作单元，这些操作**要么全部执行成功，要么全部执行失败。**

## 1.1 ACID 事务特性

**1、原子性（基于undolog回滚日志）**：事务是不可分割的最小单元（一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在某个中间环节）

**2、隔离性（基于MVCC多版本并发控制）**：数据库系统提供隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。

**3、持久性（基于redolog日志）**：事务一旦提交或回滚，它对数据库中的数据改变就是永久的

**4、一致性**：事务完成时，所有的数据保持一致状态。

## 1.2 事务的隔离级别

**1. READ UNCOMMITTED（读未提交）**：允许一个事务读取另一个事务未提交的数据。可能会导致 **“脏读”（Dirty Read）**，即读取到未提交的、可能被回滚的数据。

**不加任何锁，性能最高但一致性最差。**

**2. READ COMMITTED（读已提交）**：一个事务只能读取到另一个事务已经提交的数据。可能会导致 **“不可重复读”（Non-Repeatable Read）**，即在同一个事务中，两次读取同一数据可能得到不同的结果。

**每次SELECT都会生成新的 ReadView。**

**3. REPEATABLE READ（可重复读）** 在同一个事务中，多次读取同一数据时，结果是一致的。即使其他事务修改了数据，也不会影响当前事务的读取结果。可能会导致 **“幻读”（Phantom Read）**，即在同一个事务中，两次查询的结果集不同（例如，其他事务插入了新数据）。

**事务首次SELECT时创建ReadView,后续复用。**

**4. SERIALIZABLE（可序列化）** 这是最高的隔离级别，事务被完全隔离，完全按照顺序执行，避免了脏读、不可重复读和幻读的问题。
问题：性能开销较大，因为事务之间需要严格的锁定。

**使用严格的共享锁和排他锁，所有的SELECT自动转换为SELECT….LOCK IN SHARE MODE。**

## 1.3 并发事务问题

**1、脏读：** 一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来

![image.png](%E4%BA%8B%E5%8A%A1%2085b78c72cbfc4c6f9ba9bb5582d2412b/image.png)

**2、不可重复读：** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

![image.png](%E4%BA%8B%E5%8A%A1%2085b78c72cbfc4c6f9ba9bb5582d2412b/image%201.png)

**3、幻读：** 幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

![image.png](%E4%BA%8B%E5%8A%A1%2085b78c72cbfc4c6f9ba9bb5582d2412b/image%202.png)

## 1.4 mysql是怎么解决并发问题的？

**1、锁机制**：MySQL提供了**多种锁机制来保证数据的一致性**，包括行级锁、表级锁、页级锁等。通过锁机制，可以在读写操作时对数据进行加锁，确保同时只有一个操作能够访问或修改数据。

**2、事务隔离级别：** Mysql提供了多种事务隔离级别，通过设置合适的事务隔离级别，可以在多个事务并发执行时，控制事务之间的隔离程度。

**3、MVCC：** Mysql 使用MVCC来管理并发访问。

## 1.5 mysql长事务可能会导致哪些问题？

- **长时间的锁竞争，阻塞资源**  长事务持有锁的时间较长，容易导致其他事务在尝试获取相同锁时发生阻塞，从而增加系统的等待时间和降低并发性能。
- **死锁风险**  长事务更容易产生死锁，因为多个事务可能在互相等待对方释放锁，导致系统无法继续执行。
- **复制延迟：主从延迟**  长事务在主库执行时间过长，可能导致从库复制延迟，影响数据一致性。

# 2 InnoDB默认的隔离级别：可重复读

InnoDB实现的可重复读的隔离级别，在一定程度上可以解决幻读问题：

1、快照读：由MVCC机制来保证不出现幻读。

2、当前读：使用Next-Key Lock进行加锁来保证不出现幻读，**Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。**

# **3 MVCC 多版本并发控制**

---

**为什么使用MVCC？**—>  解决用**锁带来的性能问题**。

1、MVCC**读不阻塞写，写不阻塞读，相比较锁，减少了读写冲突** 

2、MVCC通过版本控制轻松回滚事务，**无需复杂的锁管理。**

如果没有MVCC，系统必须频繁的对读写操作进行加锁来保证数据的正确性，**因为增加了锁的获取和释放的开销，会导致整体系统响应速度变慢。**

---

**MVCC** 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的 **一致性和隔离性。**

通过  **“版本链”**  来控制并发事务控制访问同一个记录的行为。

`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。

在内部实现中，`InnoDB` 通过**数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，**如不可见，则**通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。**

## 3.1 隐藏字段

在内部，`InnoDB` 存储引擎为每行数据添加了三个隐藏字段：

 - **`DB_TRX_ID（6字节）`**：表示 **最后一次插入或更新该行的事务 id。** 此外，`delete` 操作在内部被视为更新，只不过会在记录头 `Record header` 中的。
 - **`DB_ROLL_PTR（7字节）`** **回滚指针**，指向该行的 `undo log` 。**如果该行未被更新，则为空。**
 - **`DB_ROW_ID（6字节）`**：如果没有设置主键且该表没有唯一非空索引时，`InnoDB` 会使用该 id 来生成聚簇索引。

## 3.2 Read View

```java
class ReadView {
  /* ... */
private:
  trx_id_t m_low_limit_id;      /* 大于等于这个 ID 的事务均不可见 */

  trx_id_t m_up_limit_id;       /* 小于这个 ID 的事务均可见 */

  trx_id_t m_creator_trx_id;    /* 创建该 Read View 的事务ID */

  trx_id_t m_low_limit_no;      /* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */

  ids_t m_ids;                  /* 创建 Read View 时的活跃事务列表 */

  m_closed;                     /* 标记 Read View 是否 close */
}
```

![image.png](%E4%BA%8B%E5%8A%A1%2085b78c72cbfc4c6f9ba9bb5582d2412b/image%203.png)

可重复读，启动时生成一个Read View,然后整个事务期间都在用这个Read View

读提交 **：每次读取数据时，都会生成一个新的Read View**

---

## 3.3 undo-log

`undo log` 主要有两个作用：

- 当事务回滚时用于将数据恢复到修改前的样子
- 另一个作用是 `MVCC` ，当读取记录时，**若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前的版本数据，以此实现非锁定读。**

## 3.4 工作原理

1、数据读取：事务读取数据时，根据**Read View**判断哪个版本可见。

2、数据写入：事务修改数据时，**生成新版本并更新版本链**。**旧版本数据保留在Undo Log中，供其他事务读取。**

3、事务提交：事务提交后，新版本数据对其他事务可见。

# 4 幻读现象

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它**很大程度上避免幻读现象（并不是完全解决了）**

1、针对**快照读（普通 select 语句）**，是**通过 MVCC 方式解决了幻读。**

因为**可重复读隔离级别**下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。

2、针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**

临键锁：结合记录锁和间隙锁，**锁定记录及其前后的间隙。**

如果有其他事务在 next-key lock 锁范围内插入了一条记录，**那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。**

### 个别情况造成幻读无法解决（这个常常会被追问）

这两个解决方案是很大程度上解决了幻读现象，但是还是有**个别的情况**造成的幻读现象是无法解决的。

---

- 对于快照读， MVCC 并不能完全避免幻读现象。

因为**当事务 A 更新了一条事务 B 插入的记录**，那么**事务 A 前后两次查询的记录条目就不一样**了，所以就发生幻读。

举例

![屏幕截图 2025-03-11 131651.png](%E4%BA%8B%E5%8A%A1%2085b78c72cbfc4c6f9ba9bb5582d2412b/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-03-11_131651.png)

事务A查询id = 5的记录，此时表中是没有该记录的，所以查询不出来。

然后事务B插入一条id = 5的记录，并且提交了事务。

事务A更新id = 5这条记录（事务A看不到id = 5这条记录，但是他更新了这条记录，这确实很违和，这就是幻读）

时序图如下：

![屏幕截图 2025-03-11 132707.png](%E4%BA%8B%E5%8A%A1%2085b78c72cbfc4c6f9ba9bb5582d2412b/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-03-11_132707.png)

- 对于当前读

如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。

```sql
-- T1时刻,事务 A
START TRANSACTION;
SELECT * FROM t WHERE id > 100; -- 快照读，返回空集

-- T2时刻，事务 B
START TRANSACTION;
INSERT INTO t (id, value) VALUES (101, 'new data');
COMMIT;

-- T3时刻 事务 A
SELECT * FROM t WHERE id > 100 FOR UPDATE; -- 当前读，发现事务 B 插入的记录，发生幻读
COMMIT;
```

---
