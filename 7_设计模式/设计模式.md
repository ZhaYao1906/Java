# 设计模式

# 第一章 设计模式相关内容介绍

## 1.1 设计模式概述

设计模式是一套被反复使用，多数人知晓的，经过分类编目的、代码设计经验的总结。描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。

### 设计模式分类

**1、创建型模式：**用于描述**“怎样创建对象”**，它的主要特点是**“将对象的创建和使用分离”。**（某种意义上来说，实现了解耦）

**2、结构型模式：**用于描述如何将**类或对象按某种布局组成更大的结构。**

**3、行为型模式：**用于描述 类或对象之间**怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。**

## 1.2 UML图

统一建模语言（Unified Modeling Language , UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态和静态信息。

### 类图（UML图中的一种）

类图（Class diagram）是显示了模型的静态结构，特别是模型中的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类是面向对象建模的主要组成部分。

### 类图表示法

在UML类图中，类使用包含类名、属性和方法且带有分割线的矩形来表示，比如下面的Employee类：

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image.png)

---

注意：

1、属性/方法名称前的符号表示了这个属性和方法的可见性。

+ 表示 public，- 表示private，# 表示protected

2、**属性的完整表示方式 ： 可见性 名称 ： 类型 [ = 缺省值 ]**

      **方法的完整表示方式：** **可见性 名称（参数列表） [ : 返回类型 ]**

---

### 类与类之间关系的表示方式

**1.2.1 关联关系** 

关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系（老师与学生）

- **单向关联**

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%201.png)

- **双向关联**

      双向关联就是双方**各自持有对方类型的成员变量。**

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%202.png)

- **自关联**

     自己包含自己

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%203.png)

**1.2.2 聚合关系**

是整体与部分之间的关系**(空心棱形箭头)**，但是**成员对象可以脱离整体对象而独立存在**（比如 Teacher脱离了University任然可以存在）

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%204.png)

**1.2.3 组合关系**

组合表示类之间的整体和部分的关系 **(实心棱形箭头)** ，但**它是一种更强烈的聚合关系。**在组合关系中。整体对象可以控制部分对象的生命周期，**一旦整体对象不存在，部分对象也将不存在，**部分对象不能脱离整体对象而存在。（例如头和嘴的关系）

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%205.png)

**1.2.4 依赖关系**

**依赖关系是一种使用关系，**它是对象间 **耦合度最弱 的一种关联方式（临时性关联）。**在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%206.png)

用虚线箭头表示，箭头从使用类指向被依赖的类。

**1.2.5 继承关系**

继承关系是对象之间耦合度最大的一种关系，**是父类与子类之间的关系。**

在UML类图中，泛化关系用带空心的三角箭头的实现来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%207.png)

**1.2.6 实现关系**

实现关系是**接口与实现类之间的的关系**。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。

使用带空心的三角箭头的虚线来表示。从实现类指向接口。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%208.png)

## 1.3 软件设计原则（被问过 ）

SOLID原则是面向对象设计中的一组重要的设计原则，旨在提高代码的可维护性、可扩展性和可读性。分别是：

1. **单一职责原则（Single Responsibility Principle, SRP）**

一个类应该只有一个发生变化的原因。如果一个类负责多个功能，那么当其中一个功能发生变化时，可能会影响到其他功能。

1. **开闭原则（Open/Closed Principle, OCP）**
2. **里氏代换原则（Liskov Substitution Principle, LSP）**
3. **接口分离原则（Interface Segregation Principle, ISP）**
4. **依赖倒置原则（Dependency Inversion Principle, DIP）**

### 开闭原则

**对扩展开放，对修改关闭。**在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔的效果。

要想达到这样的效果，**我们需要使用接口和抽象类。（接口和抽象类很像，但是是有区别的）**

可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

### 里氏代换原则

任何基类可以出现的地方，子类一定可以出现。通俗理解：**子类可以扩展父类的功能，但不能改变父类原有的功能（尽量不要重写父类的方法）**。整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序出错的概率非常大。

**举例：**

**1）错误的例子**

```java
class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins cannot fly");
    }
}
```

`Penguin` 类覆盖了 `fly()` 方法并抛出了异常，这违反了里氏代换原则，因为父类 `Bird` 的行为是“会飞”，而子类 `Penguin` 的行为是“不会飞”，两者不一致。

**2) 正确的实现**

```java
class Bird {
    public void fly() {
        System.out.println("Bird is flying");
    }
}

class FlyingBird extends Bird {
    @Override
    public void fly() {
        System.out.println("FlyingBird is flying");
    }
}

class Penguin extends Bird {
    @Override
    public void fly() {
        System.out.println("Penguin cannot fly");
    }

    public void swim() {
        System.out.println("Penguin is swimming");
    }
}
```

在这个正确的实现中，`Bird` 类是一个抽象类，表示所有鸟的基本行为。`FlyingBird` 类继承自 `Bird`，并实现了飞行行为。而 `Penguin` 类虽然继承自 `Bird`，但它重写了 `fly()` 方法，明确表示企鹅不会飞，并且新增了 `swim()` 方法表示企鹅会游泳。这样，`Penguin` 类的行为与父类 `Bird` 类的行为保持一致，同时又具有自己的独特行为，符合里氏代换原则。

### 依赖倒转原则

**高层模块（业务逻辑）不应该依赖低层模块（具体实现），两者都应该依赖其抽象（接口或实现类）；抽象不应该依赖细节，细节应该依赖抽象。**简单来说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

**举例：**

```java
// 1. 定义抽象接口
interface Database {
    void save(String data);
}

// 2. 低层模块实现接口
class MySQLDatabase implements Database {
    @Override
    public void save(String data) {
        System.out.println("使用MySQL保存数据: " + data);
    }
}

class OracleDatabase implements Database {
    @Override
    public void save(String data) {
        System.out.println("使用Oracle保存数据: " + data);
    }
}

// 3. 高层模块依赖抽象
class DataService {
    private Database database;  // 依赖抽象
    
    // 4. 通过构造器注入依赖（依赖注入）
    public DataService(Database database) {
        this.database = database;
    }
    
    public void save(String data) {
        database.save(data);
    }
}

// 使用
public class GoodExample {
    public static void main(String[] args) {
        // 可以灵活切换数据库实现
        Database mySQL = new MySQLDatabase();
        DataService service1 = new DataService(mySQL);
        service1.save("MySQL数据");
        
        Database oracle = new OracleDatabase();
        DataService service2 = new DataService(oracle);
        service2.save("Oracle数据");
    }
}

```

### 接口隔离原则

客户端不应该被迫依赖于它不使用的方法；**一个类对另一个类的依赖应该建立在最小的接口上。**

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%209.png)

### 迪米特法则

迪米特法则又叫最少知识法则。**一个对象应该对其他对象保持最少的了解，只与直接的朋友通信。（只和你的直接朋友朋友交谈，不跟“陌生人”说话）。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用。可以通过第三方转发该调用。**其目的是降低类之间的耦合度，提高模块的相对独立性。（动态代理？？？有点像）

**举例：分层架构 → 表现层不应该直接访问数据访问层，服务层作为中介协调各层交互，每个层只与直接相邻的层通信。**

### 合成复用原则

尽量先使用 **组合或聚合 等关联关系**来实现，**其次才考虑使用 继承 关系**来实现。

继承复用虽然有简单和易实现的优点，但也存在：

**1、继承复用破坏了类的封装性。**因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用也称为“白箱”复用。

**2、子类与父类的耦合度高。**父类的任何实现改变都会导致子类的实现发生变化，不利于类的扩展与维护。

**3、限制了复用的灵活性，**从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

---

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能。

1、维护了类的封装性。因为成分对象的内部细节是新对象看不见的，这种复用又称为“黑箱”复用。

2、对象间耦合度低，可以在类的成员位置声明抽象。

3、复用的灵活性高，这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同地对象。

**举例：汽车类内含引擎类**

```java
// 汽车类使用组合而非继承
class Car {
    private Engine engine;  // 组合关系
    
    public Car(Engine engine) {
        this.engine = engine;
    }
    
    public void start() {
        engine.start();
    }
    
    public void stop() {
        engine.stop();
    }
    
    // 可以动态更换引擎
    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}

// 使用示例
public class CompositionExample {
    public static void main(String[] args) {
        // 创建汽油车
        Car gasolineCar = new Car(new GasolineEngine());
        gasolineCar.start();
        gasolineCar.stop();
        
        // 创建电动车
        Car electricCar = new Car(new ElectricEngine());
        electricCar.start();
        electricCar.stop();
        
        // 将汽油车改装为电动车
        gasolineCar.setEngine(new ElectricEngine());
        gasolineCar.start();
    }
}

```

# 第二章 创建者模式（5种）

## 2.1 单例模式

涉及到一个单一的类**（最简单的一种）**，**该类负责创建自己的对象，同时确保只有单个对象被创建。这个**类提供了一种访问其唯一的对象的方式。**可以直接访问，不需要实例化该类的对象。**

**单例设计模式：**

- **饿汉式 ：类加载就会导致该单实例对象就会被创建。**

```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {
        // 私有化构造函数，防止外部直接实例化
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

- **懒汉式 ：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会被创建。**

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {
        // 私有化构造函数
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- **双检锁单例：**在第一次使用时才创建对象，通过双重校验锁实现线程安全，同时避免了每次调用getInstance方法时的同步开销。

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
        // 私有化构造函数
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 存在问题

破坏单例模式 ： 使用单例类可以创建多个对象，枚举方式除外，有两种方式，分别是**序列化和反射。**

解决：

**1、序列化、反序列化方式破坏单例模式**的解决方法：**在Singleton类中添加readReslove()方法，**在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。   

**2、反射方式**破解单例的解决方法 ： 在加载时判断对象是否已经创建过滤。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/e5af4428-36f4-4ec7-90d2-8f674324c964.png)

## 2.2 工厂方法模式

创建对象时直接**new该对象**，就会对**该对象耦合严重**。假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。

如果我们使用工厂来生产对象，我们就**只和工厂打交道**就可以了，彻底和对象解耦，**如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的。**

**工厂模式的最大优点：解耦**

**工厂方法模式和抽象工厂模式都属于工厂模式。**

### 定义

**定义一个用于创建对象的接口，让子类决定实例化哪个产品对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。**

### 结构

1、抽象工厂 ： 提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。

2、具体工厂 ： 主要是实现抽象工厂中的抽象方法，完成具体产品的创建。

3、抽象产品 ： 定义了产品的规范，描述了产品的主要特性和功能。

4、具体产品 ： 实现了抽象 产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一 一对应。

### 优缺点

**优点 ： 用户只需要知道具体工厂的名称就可以得到所要的产品，无需知道产品的具体创建过程。**

**在系统增加新的产品时，只需要添加具体产品类和对应的具体工厂类，无需对原工厂进行任何修改，满足开闭原则。**

**缺点 ： 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。**

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2010.png)

## 2.3 抽象工厂模式

工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机等。**这些工厂只生产同种类产品，同种类产品称为同等级产品。**也就是说：工厂方法模式只考虑生产同等级的产品。

抽象工厂模式将考虑多等级产品的生产，**将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。（产品族 == 公司、产品等级 == 同类产品）**

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2011.png)

### 结构

**基本和工厂方法一致，有细微差别**

**1、抽象工厂 ： 提供了创建产品的接口，它包含多个创建产品的方法，可以用来创建多个不同等级的产品。**

2、具体工厂 ：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 

3、抽象产品 ： 定义了产品的规范，描述了产品的主要特性和功能，**抽象工厂模式有多个抽象产品。**

4、具体产品 ： 实现了抽象产品角色所定义的接口，由具体工厂来创建，**它同具体工厂之间是多对一的关系。**

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2012.png)

下面两个是抽象工厂类（AmericanDessertFactory、ItalyDessertFactory），可以用来创建多个不同等级的产品。

### 优缺点

优点 ： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

缺点 ： 当产品族中需要增加一个新的产品时，所有工厂类都需要进行修改。

### 模式扩展

**简单工厂 + 配置文件解除耦合 ：** 可以通过工厂模式 + 配置文件的方式解除工厂对象和产品对象的耦合。

## 2.4 原型模式

### 定义

用一个已经创建的实例作为原型**，通过复制该原型对象来创建一个和原型对象相同的新对象。**

### 结构

1、抽象原型类 ： 规定了具体原型对象必须实现的clone()方法。 

2、具体原型类 ： 实现抽象原型类的clone()方法，它是可以被复制的对象。

3、访问类 ：使用具体原型类中的clone()方法来复制新的对象。

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2013.png)

**原型模式分为浅克隆和深克隆。（这个Java基础里面有）**

## 2.5 建造者模式

将一个复杂对象的建构与表示分离，使得同样的构建过程可以创建不同的表示。

**分离了部件的构造（由Builder来负责）和装配（由Director负责）。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。**

由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。

建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无需知道其内部的具体构造细节。（就像组装电脑一样）

---

### 结构

1、抽象建造者类（Builder）: 这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。

2、具体建造者类（ConcreteBuilder）: 实现Builder接口，完成复杂产品的各个部件的具体创建方法。在构造完成后，提供产品的实例。

3、产品类（Product）：要创建的复杂对象。

4、指挥者类（Director）: **调用具体的建造者来创建复杂对象的各个部分，**在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2014.png)

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2015.png)

---

### 优缺点

**优点：**

建造者模式的封装性很好，使用建造者模式可以有效的封装变化。

建造者模式也很容易进行扩展，如果有新的需求，通过实现一个新的建造者类就可以完成，基本不用修改之前已经测试通过的代码。

**缺点：**

**建造者模式所创建的产品一般具有较多的共同点**，其组成部分相似，**如果产品之间差异很大，则不太适合建造者模式。因此其使用范围受到一定限制。**

---

### 模式扩展

建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码的可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。

**例子·：**

```java
public class Phone{
		private String cpu;
		private String screen;
		private String memory;
		private String mainboard;
		
		//构造私有方法
		private Phone(Builder builder){
				this.cpu = builder.cpu;
				this.screen = builder.screen;
				this.memory = builder.memory;
				this.mainboard = builder.mainboard;
		}
		
		public static final class Builder{
				private String cpu;
				private String screen;
				private String memory;
				private String mainboard;
				
				public Builder cpu(String cpu){
						this.cpu = cpu;
						return this;
				}
				
				public Builder screen(String screen){
						this.screen = screen;
						return this;
				}
				
				public Builder memory(String memory){
						this.memory = memory;
						return this;
				}
				
				public Builder mainboard(String mainboard){
						this.mainboard = mainboard;
						return this;
				}			
		}
		//使用构建者创建Phone对象
		public Phone build(){
				return new Phone(this);
		}
		
		
}
```

调用：

```java
public class Client{
		public static void main(String[] args){
		//构造非常方便，顺序也可以改,支持链式编程
				Phone phone = new Phone.Builder()
												.cpu("intel")
												.screen("三星屏幕")
												.memoty("xxxx")
												.build();
		}
}
```

## 总结

工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程。抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品；具有不同分类维度的产品组合，采用抽象工厂模式是不需要关心构建过程，只关心什么产品由什么工厂生产即可。

# 第三章 结构型模式（7种）

结构型模式描述如何**将类或对象按某种布局组成更大的结构。**它分为**类结构型模式和对象结构型模式**，前者采用**继承机制**来组织接口和类、后者采用**组合或聚合**来组合对象。由于组合或聚合关系比继承关系耦合度低，满足”合成复用原则“，所以**对象结构型模式比类结构型模式具有更大的灵活性。**

## 3.1 代理模式

由于某些原因需要给某对象提供一个代理以控制对该对象的访问。**这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。**

Java中的代理按照代理类生成的时机不同又分为静态代理和动态代理，**静态代理代理类在编译时就生成，而动态代理代理类则是在Java运行时动态生成。**动态代理又有 JDK代理 和 CGLib代理 两种。

### 结构

1、抽象主题（Subject）类 ： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。

2、真实主题类 ： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象

3、代理类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或拓展真实主题的功能。

### JDK动态代理

Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance 方法）来获取代理对象。

### CGLib动态代理

JDK动态代理要求必须定义接口，对接口进行代理。CGLib是第三方提供的包，所以需要引入jar包的坐标。

step1、创建Enhancer对象，类似于JDK代理中的Proxy类。

step2、设置父类的字节码对象。

step3、设置回调函数。

step4、创建代理对象。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2016.png)

通过intercept方法实现动态代理。（类似于invoke()）

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2017.png)

### 总结

使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，**使用字节码技术生成代理类。**

唯一需要注意的是，CGLib不能对声明为final的类或方法进行代理，因为CGLib原理是动态生成被代理类的子类。

### 静态代理与动态代理

动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。

如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，**所有的代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题。**

## **3.2 适配器模式**

**将一个类的接口转换成客户希望的另外一个接口，**使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

**适配器模式分为类适配器模式和对象适配器模式**，前者类之间耦合度比后者高，且要求程序员了解现有组件库中的相关组件内部结构，所以应用相对少些。

### 结构

目标接口 ：当前系统业务所期待的接口，它可以是抽象类或接口。

适配者类 ：它是被访问和适配的**现存组件库中的组件接口**。

适配器类 ：它是一个**转换器**，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

### 类适配器模式

实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2018.png)

SDCard 和 SDcardImpl 是目标接口，TFCard 和 TFCardImpl是适配者类（被访问和适配的现存组件库中的组件接口）SDAdapterTF是适配器类，它是一个转换器。

类适配器模式违背了合成复用原则，类适配器是客户类有一个接口规范的情况下可用，反之不可用。

### 对象适配器模式

实现方式 ：**对象适配器模式可采用将现有组件库中已实现的组件引入适配器类中**，该类同时实现当前系统的业务接口。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/07038650-453b-44b2-8ff4-38447829ba34.png)

注意对象适配器模式和类适配器模式的区别：SDAdapterTF 是直接聚合TFCard的接口，不是直接继承TFCardImpl的实现类。

---

类适配器模式下的：

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2019.png)

对象适配器模式下的：

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2020.png)

应用场景 ： 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

### JDK源码中的适配器模式 — InputStreamReader

Reader（字符流）、InputStream (字节流)的适配使用的是InputStreamReader。

## 3.3 桥接模式

**背景** ：在一个有多种可能会变化的维度的系统中，**用继承方式会造成类爆炸，扩展起来不灵活，每次在一个维度上新增一个具体实现都要增加多个子类，为了更灵活的设计系统，**我们此时可以考虑用桥接模式。

**定义** ： 将抽象与实现分离，使它们可以独立变化。它是用**组合关系代替继承关系**来实现，从而降低了抽象和实现两个可变维度的耦合度。

### 结构

1、抽象化角色 ： 定义抽象类，并包含一个大于实现化对象的引用。

2、扩展抽象化角色 ： 是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。

3、实现化角色 ： 定义实现化角色的接口，供扩展抽象化角色调用。

4、具体实现化角色 ： 给出实现化角色接口的具体实现。

### 示例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2021.png)

视频播放器包含两个维度，不同的操作系统平台（Windows、Mac、Linux）和不同的视频格式（RMVB、AVI、WMV）,该播放器包含两个维度，适合使用桥接模式。

VideoFile 是实现化角色。AVIFile 和 RMVBFile是具体实现化角色。OperatingSystem相当于一个抽象化角色，而Windows 和 Mac 相当于一个扩展抽象化角色。

### 优点

桥接模式提高了系统中的可扩充性，在两个变化维度中任意扩展一个维度，都不需要改变原有系统。

### 使用场景

当一个类存在两个独立变化的维度，且这两个维度都需要扩展时。

## 3.4 装饰者模式

**背景** ：使用继承方式存在的问题 ： 1、扩展性不好，如果再要加一种配料（火腿肠），我们就会发现需要给FriedRice 和 FriedNoodles分别定义一个子类，如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。2、产生过多的子类。

**定义** ：指**在不改变现有对象结构的情况下**，**动态地给该对象增加一些职责（即增加其额外功能）**的模式。

### 结构

装饰模式中的角色：

1、抽象构件角色 ： 定义一个抽象接口以规范准备接收附加责任的对象。

2、具体构建角色 ： 实现抽象构件，通过装饰器角色为其添加一些职责。

3、抽象装饰角色 ： 继承或实现抽象构建，并包含具体构建的实例，可以通过其子类扩展具体构建的功能。

4、具体装饰角色 ： 实现抽象装饰的相关方法，并给具体构建对象添加附加的责任。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2022.png)

FastFood是快餐类（具体构建角色），Garnish相当于装饰器（抽象装饰角色），Eggs和Bacon相当于配料（具体装饰角色）。

### 好处

1、装饰者模式**可以带来比继承更加灵活性的扩展功能**，使用更加方便，可以通过**组合不同的装饰者对象来获取具有不同行为状态的多样性结果。**装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。

2、**装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个代替模式**，装饰模式可以动态的扩展一个实现类的功能。

### 使用场景

当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。

### JDK源码解析

IO流中的包装类使用到了装饰者模式。BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2023.png)

BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率

---

### 代理和装饰者的区别

静态代理和装饰者模式的区别

相同点 ：1、都要实现与目标类相同的业务接口 2、在两个类中都要声明目标对象 3、都可以在不修改目标类的前提下增强目标方法

不同点 ： 1、装饰者是为了增强目标对象，静态代理是为了保护和隐藏目标对象

2、获取目标对象构建的地方不同 ： 装饰者是由外界传递进来，可以通过构造方法传递，静态代理是在代理类内部创建，以此来隐藏目标对象。 

## 3.5 外观模式

**为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式，**该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2024.png)

### 结构

外观模式包含角色：

1、外观角色 ： 为多个子系统提供一个共同的接口。

2、子系统角色 ： 实现系统的部分功能，客户可以通过外观角色访问它

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2025.png)

### 优点

降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响到它的客户类

### 缺点

不符合开闭原则，修改很麻烦

### 使用到外观模式 — tomcat

tomcat作为web容器，接收浏览器发过来的请求，tomcat会将请求封装成ServletRequest对象

## 3.6 享元模式

运用**共享技术**来有效地支持**大量细粒度对象的复用**，它通过**共享已经存在的对象来大幅度减少需要创建的对象数量，**避免大量相似对象的开销，从而提高系统资源的利用率。

### 结构

享元模式的状态 ：

1、内部状态 ： 不会随着环境的改变而改变的可共享部分。

2、外部状态 ： 随环境改变而改变的不可以共享的部分。

---

享元模式的角色 ：

1、抽象享元角色 ：通常是一个接口或抽象类，在抽象享元中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）

2、具体享元角色 ： 它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。

3、非享元角色 ： 并不是所有的抽象享元类都需要被共享，不能被共享的子类可以设计为非共享具体享元类

4、享元工厂：负责创建和管理享元角色，当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象。

### 示例 俄罗斯方块

每个不同的方块都是一个实例对象，这些对象就可以用享元模式来实现 

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2026.png)

### 优点

极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能

### 使用场景

一个系统有大量相同或相似的对象，造成内存的大量耗费。

### JDK中使用：Integer类中使用了享元模式

```java
Integer i1 = 127;
//反编译后
Integer i1 = Integer.valueOf((int)127);
```

直接给Integer类型的变量赋值基本数据的操作底层使用的valueOf()。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2027.png)

low是-128 high是127

Integer默认先创建并缓存 -128~127之间数的Integer对象，当调用valueof时，如果参数在-128~127之间则计算下标并从缓存中返回，否则创建一个新的Integer对象。

## 3.7 组合模式

**1、背景 ：** 在树型结构中，可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关操作。**（我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦）**

**2、定义 ：** 组合模式又名部分整体模式，**是用于把一组相似的对象当作一个单一的对象。**组合模式**依据树型结构**来组合对象，用来**表示部分以及整体层次。**这种类型的设计模式属于结构型模式，它创建了对象组的树型结构。

### 结构

1、抽象根节点 ： 定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。

2、树枝节点 ： 定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树型结构。

3、叶子节点 ： 叶子节点对象，其下再无分支，是系统层次遍历的最小单位。

### 案例 — 软件菜单

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2028.png)

MenuComponent 相当于抽象根节点。Mean继承了MeanComponent，同时又聚合了MeanComponent。

感觉组合模式就是树的模式。

### 组合模式分类

使用组合模式时，根据**抽象构件类的定义形式（MenuComponent）**我们可以将组合模式分为透明组合模式和安全组合模式两种形式。

1、透明组合模式 ：抽象根节点声明了所有用于管理成员对象的方法。 

2、安全组合模式 ：在抽象构建角色中没有声明任何用于管理成员对象的方法。

### 使用场景

组合模式就是对应树型结构的场景

# 第四章 行为型模式（11种）

行为型模式用于描述程序在运行时复杂的流程控制，即**描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，**它涉及算法与对象间职责的分配。

行为型模式分为类行为模式和对象行为模式，前者采用**继承机制来在类间分派行为**，后者采用**组合或聚合在对象间分配行为**。由于组合关系或聚合关系比继承关系耦合度低，满足**“合成复用原则”**，所以对象行为模式比类行为模式具有更大的灵活性。

除了模板方法模式和解释器模式是类行为模式，其他全部属于对象行为模式。

## 4.1 模板方法模式

面向对象程序语言设计过程中，经常会遇到 ：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，**但某些步骤的具体实现还未知，或者说某些步骤的具体实现与具体环境有关。**

### 定义

定义一个操作中的算法骨架，而**将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤**

### 结构

1、抽象类 ：负责给出一个算法的轮廓和骨架，它由一个模板方法和若干基本方法构成

模板方法 ：定义了算法的骨架，按某种顺序调用其包含的基本方法

基本方法 ：是实现算法各个步骤的方法，是模板方法的组成部分；（抽象方法、具体方法、钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种，一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx,返回值一般是boolean类型）

2、具体子类 ：实现抽象类中所定义的抽象方法和钩子方法。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2029.png)

顺序是固定的，但倒蔬菜和倒调料品确视具体情况而定。

### 优点

提高代码的复用性

### 缺点

对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。

### 适用场景

算法整体步骤固定，但其中个别部分易变时，这时候可以使用模板方法模式。

### 模板方法模式的使用 — InputStream类

InputStream类就使用了模板方法模式，在InputStream类中定义了多个read()方法。

## 4.2 策略模式

该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，但算法的变化不会影响使用算法的用户**。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。**

### 结构

1、抽象策略类 ：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略所需要的接口。

2、具体策略类 ：实现了抽象策略定义的接口，提供具体的算法实现或行为。

3、环境类 ：持有一个策略类的引用，最终给客户端使用。

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2030.png)

促销活动就是不同的算法。

### 优缺点

优点 ： 策略类之间可以自由切换、易于扩展。

缺点 ：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。

### 使用场景

系统中各算法彼此完全独立，且要求客户隐藏具体算法的实现细节

### 策略模式的应用 — Comparator

在Arrays类中有一个sort()方法，对参数进行排序的规则（策略）是我们自定义的。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2031.png)

## 4.3 命令模式

**将一个请求封装为一个对象**，使**发出请求的责任与执行请求的责任分开**，这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用与管理。**（有点像消息队列）**

---

### 结构

1、抽象命令角色 ：定义命令的接口，声明执行的方法。

2、具体命令角色 ：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。

3、实现者/接收者 ：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。

4、调用者/请求者 : 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象，这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。

---

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2032.png)

### 优缺点：

优点 ： 1、降低系统的耦合度，命令模式能将调用操作的对象与实现该操作的对象解耦 2、增加或删除命令非常方便

缺点 ： 1、使用命令模式可能会导致某些系统有过多的具体命令类 **2、系统结构更加复杂**

### **使用场景**

系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。

### 命令模式的应用 Runable

Runable 是一个典型命令模式，Runable担当命令的角色，Thread充当调用者，start方法就是其执行的方法。

## 4.4 责任链模式

一个请求可以有多个对象可以处理，但**每个对象的处理条件或权限不同。**

为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住下一个对象的引用而连成一条链；当有请求发生时，可沿着这条链传递，直到有对象处理它为止。

### 结构

1、抽象处理者 ：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。

2、具体处理者 ：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。

3、客户类 ： 创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

### 优缺点

优点 ： 降低了对象之间的耦合度，该模式降低了请求发送者和接收者的耦合度。

缺点 ： 1、不能保证每个请求一定被处理，由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。

2、对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。

### 责任链模式应用 — FilterChain

在 javaWeb 应用开发中，FilterChain是职责链（过滤器）模式的典型应用。

## 4.5 状态模式

控制状态，每一种状态的改变，都需要根据其他状态来更新处理。

状态模式 ：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

### 结构

1、环境角色 ：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。

2、抽象状态角色 ：定义一个接口，用以封装环境对象中特定状态所对应的行为。

3、具体状态角色 ：实现抽象状态所对应的行为。

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2033.png)

### 优缺点

1、优点 ：将所有与某个状态有关的行为放到一个类中，并且可以方便的增加新的状态

2、缺点：会增加系统类和对象的个数。状态模式的结构与实现都较为复杂。

### 使用场景

当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。

## 4.6 观察者模式

概述 ： 又被称为**发布-订阅模式(Publish/Subscribe)模式，**它定义了一种**一对多的依赖关系**，让**多个观察者对象**同时监听**一个主题对象**。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。

### 结构

1、抽象主题 ：抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。

2、具体主题（具体被观察者）：该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。

3、抽象观察者：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己

4、具体观察者：实现抽象观察者定义的更新接口，以便在得到主题更改时更新自身的状态。

### 优缺点

1、优点 ：降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。

2、缺点：如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时。

### 案例实现

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2034.png)

### 使用场景

对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。

### JDK中提供的实现：Observable类和Observer接口

在Java中，通过java.util.Observable类和java.util.Observer接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。

## 4.7 中介者模式

一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构。这是一种过度耦合的架构，即不利于类的复用，也不稳定。

**如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图可看到，任何一个类的变动只会影响类的本身，以及中介者，这样就减少了系统的耦合。**

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2035.png)

定义 ： 中介者模式又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立的改变它们之间的交互。

### 结构

1、抽象中介者角色 ：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。 

2、具体中介者角色 ：实现中介接口，定义一个List来管理同事对象，协调各个同事角色之间的交互关系。

3、抽象同事角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响同事类的公共功能。

4、具体同事角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

### 案例实现

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2036.png)

Mediator就是抽象中介者类，Tenant（租客）就是具体同事角色，Person就是抽象同事角色。

### 优缺点

优点：松散耦合：中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合。

缺点：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。

### 使用场景

系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解

## 4.8 迭代器模式

### 定义

提供一个对象来顺序访问**聚合对象（集合）**中的一系列数据，而不暴露聚合对象的内部表示。

### 结构

抽象聚合角色 ： 定义存储、添加、删除聚合元素以及创建迭代器对象的接口

具体聚合角色：实现抽象聚合类，返回一个具体迭代器的实例。

抽象迭代器角色 ：定义访问和遍历聚合元素的接口，通常包含hasNext()、next()等方法。

具体迭代器角色 ：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2037.png)

### 优缺点

1、优点 ：**支持以不同方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式**，在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。

2、缺点 ：增加了类的个数，这在一定程度上增加了系统的复杂性。

### 使用场景

1、当需要为聚合对象提供多种遍历方式时。

2、当需要为遍历不同的聚合结构提供一个统一·的接口时。

3、当访问一个聚合对象的内容而无须暴露其内部细节的表示时。

### JDK源码解析

单列集合都使用到了迭代器 — ArrayList为例

List : 抽象聚合类    ArrayList : 具体的聚合类    Iterator : 抽象迭代器  list.iterator() : 返回的是实现了Iterator接口的具体迭代器对象。

## 4.9 访问者模式

### 定义

封装了一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。

### 结构

1、抽象访问者 ：定义了**对每一个元素（Element）访问**的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与**元素类个数（Element的实现类个数）**是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。

2、具体访问者 ：给出对**每一个元素类访问**时所产生的具体行为。

3、抽象元素角色 ：定义了一个接受访问者的方法，其意义是指，每一个元素都要可以被访问者访问。

4、具体元素角色 ：提供接收访问方法的具体实现，而这个具体实现，通常情况下是使用访问者提供的访问该元素类的方法。

5、对象结构角色 ：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。

### 优缺点

1、优点 ：扩展性好，在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能

复用性好，通过访问者来定义整个对象结构通用的功能，从而提高复用程度

2、缺点 ：对象结构变化很困难

### 使用场景

对象结构相对稳定，但其操作算法经常变化的程序。

### 扩展

访问者模式用到了一种**双分派**的技术。

## 4.10 备忘录模式

备忘录模式提供了一种状态恢复的实现机制，**使得用户可以方便地回到某一个特定的历史步骤（有点像SQL里面的日志技术）**，当新的状态无效或者存在问题时，可以暂时存储起来的备忘录将状态复原，很多软件都提供了回退操作（Ctrl + Z）

**定义：**又叫**快照模式**，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。

### 结构

1、发起人角色 ： 记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。

2、备忘录角色 ：负责存储发起人的内部状态，在需要时提供这些内部状态给发起人

3、管理者角色：对备忘录进行管理，提供保存与获取备忘录的功能，但不能对备忘录的内容进行访问与修改。

---

备忘录有两个等效的接口：

- **窄接口** ：管理者对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口，这个窄接口只允许他把备忘录对象传给其他的对象。
- **宽接口** ：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。

---

### 案例

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2038.png)

1、“ 白箱 ” 备忘录 ——> 宽接口

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2039.png)

2、“黑箱”备忘录 ——> 窄接口

备忘录角色对**发起人对象提供一个宽接口，而为其他对象提供一个窄接口**，在Java语言中，实现双重接口的办法就是将备忘录设计成发起人类的内部成员类。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2040.png)

### 优缺点

优点 ：提供了一种**可以恢复状态的机制**，当用户需要时能够比较方便地将数据恢复到某个历史的状态，实现了内部状态的封装，除了创建它的发起人之外，其他对象都不能够访问这些状态信息。

缺点 ：资源消耗大，如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。

### 使用场景

需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。

## 4.11 解析器模式

### 定义

给定一个语言，定义它的文法表示，并定义一个**解释器**，这个解释器使用该标识来解释语言中的文字。

在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”，比如加减法运算。规则为：由数值和+-符号组成的合法序列，“1+2-3”就是这种语言的句子。

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2041.png)

### 结构

1、抽象表达式 ： 定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。

2、终结符表达式 ： 是抽象表达式的子类，用来**实现文法中与终结符相关**的操作，文法中的每一个终结符都有一个具体终结表达式与之对应。

3、非终结符表达式 ：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应一个非终结符表达式。

4、环境角色 ： 通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取值。

5、客户端 ：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。

### 案例 实现加减法的软件

![image.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20128e745001648072b460c3aac6f16246/image%2042.png)

### 优缺点

1、优点 ： 易于改变和扩展文法；实现文法比较容易；增加新的解释表达式较为方便

2、缺点 ： 对于复杂文法难以维护；执行效率低（在解释器模式中使用了大量的循环和递归调用）

### 使用场景

当语言的文法比较简单，且执行效率不是关键问题时；当问题重复出现，且可以用一种简单的语言来 进行表达时；