# Java JVM

# 1. JVM基础

**定义：** JVM指的是Java虚拟机，JVM本质上 **是一个运行在计算机上的 程序** ，它的职责是 **运行Java字节码文件，不只是Java语言，Java虚拟机上也可以运行Scala,Groovy等语言。**

 ****

**作用：** 

为了支持Java中的 **Write Once,Run Anywhere；** 编写一次，到处运行的跨平台特性。

**功能：** 

1 解释和运行：将字节码文件转换成机器码文件。

2 内存管理：自动为对象、方法等 **分配内存**，自动的 **垃圾回收机制。**

3 即时编译：对热点代码进行优化，提升执行效率。

**组成：**

1 类加载子系统：**类加载器**—加载class字节码信息到内存中。

**2 运行时内存区：—管理JVM使用到的内存。**

程序计数器、栈(本地方法栈/虚拟机栈)、堆、方法区 **（类元信息，运行时常量池、字符串常量池）**

方法区：静态变量存储在 **方法区（Method Area）** 中。

元空间（方法区的实现）：元空间的本质和永久代类似，都是对JVM规范中的方法区的实现。不过元空间与永久代之间的最大区别：元空间不在虚拟机中，而是使用本地内存。

**3 执行引擎 — 解释执行字节码指令，垃圾自动回收。**

**4 本地接口 — 调用本地已经编译的方法，比如虚拟机中提供的C/C++方法。**

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image.png)

# 2.字节码文件

字节码文件本质上是一个 **二进制文件** ，无法直接使用记事本等工具打开阅读其内容，开发环境下，使用jclasslib插件，服务器环境下使用javap -v命令

**1、基本信息** 魔数、主副版本号（字节码文件对应的）、父类和接口

**2、常量池**  字面量+符号引用 保存了字符串常量、类或接口名、字段名

**3、属性**  类的属性

**4、字段** 当前类或接口声明的字段信息

**5、方法**  当前类或接口声明的方法信息

# 3.运行时数据区

线程不共享：**程序计数器、栈**  线程共享：**方法区、堆**

1、程序计数器：每个线程通过PC寄存器记录当前要执行的**字节码指令的地址** 

作用：

1.控制程序指令的进行，实现分支，跳转，异常等逻辑  

2.多线程切换

2、栈（本地方法栈、虚拟机栈）

**虚拟机栈**：**每一个方法的调用使用一个栈帧**来保存数据，**栈的生命周期和线程相同。**

**栈帧组成**

- **局部变量表：主要存放了编译期可知的各种数据类型、对象引用**
- **操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。**
- **帧数据：主要服务一个方法需要调用其他方法的场景。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。**

**本地方法栈：** 与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法栈执行native方法。

3、堆

**创建出来的对象均位于堆上，** 栈上的局部变量表，可以存放堆上对象的引用；**静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间的共享。**

4、方法区

类的元信息（字段和方法，虚方法表）

运行时常量池（字节码文件的常量池内容）

**字符串常量池（避免重复创建）JDK1.7以后从方法区拿到了堆上。**

5、直接内存（不在规范中，了解）

### **JVM内存模型里的堆和栈有什么区别？**

**堆是垃圾回收最主要的部分，堆结构更详细的划分与垃圾回收器有关**

1、用途：栈主要**用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。** 堆用于存储对象的实例（包括类的实例和数组）。**当使用new关键字创建一个对象时，对象的实例就会在堆上分配空间。**

2、生命周期：栈（方法结束调用） 堆（垃圾回收）

3、存取速度：栈快堆慢

4、存取空间：栈小堆大

### **栈中存的是什么？**

**栈实际上存储的不是对象，而是对象的引用。真正的对象都是存在堆上的。**

### 哪些区域会存在内存溢出？会有什么现象？

内存溢出是指内存中**某一块区域的使用量超过了允许使用的最大值，** 从而使用内存时因空间不足而失败，虚拟机一般会抛出指定错误。

在Java虚拟机中，只有程序计数器 **（长度固定的地址）** 不会出现内存溢出的情况。

**1、堆内存溢出：** 在堆上分配的对象空间超过了堆的最大大小，从而导致内存溢出 **（用-Xmx参数进行设置）抛出OutOfMemory错误**

**2、栈内存溢出：** 栈帧空间的占用内存超过了最大值，**(用-Xss参数进行设置) StackOverflowError**

**3、方法区溢出：** 方法区存放的内容超过了方法区内存的最大值，JDK7之前方法区使用**永久代（-XX：MaxPermSize = 值）实现**，JDK8及以后使用**元空间（-XX：MaxMetaspaceSize = 值）来实现**
抛出OutOfMemory错误

**4、直接内存溢出：** 直接内存溢出指的是申请的直接内存空间大小超过了最大值，抛出OutOfMemory错误

### JVM在JDK6-8之间，在内存区域上有什么不同？

- **方法区的实现**

**JDK8之前，** 将方法区存放在堆中的 **永久代空间**，堆的大小由虚拟机参数直接控制。

JDK8及以后，将方法区存放在 **元空间** 中，元空间位于 **操作系统** 维护的直接内存中 **（脱离了堆内存！！！，方法区是方法区，堆内存是堆内存，分割了）**，默认情况下只要不超过操作系统承受的上限，可以一直分配，也可以手动设置最大大小。

**优点：**

**1.提高内存上限，** 不会受制于堆内存。

**2.优化垃圾回收的策略**：永久代在堆上，垃圾回收一般使用老年代的垃圾回收方式，不够灵活，使用元空间之后单独设计了一套适合方法区的垃圾回收机制。

- **字符串常量池的位置**

**JDK7以前在运行时常量池  JDK7及以后放在了堆上。**

JDK7之前：运行时常量池直接包含了字符串常量池。

JDK7及以后：字符串常量池从方法区拿到了堆中。

**优点：**

**1.垃圾回收优化：** 字符串常量池的回收逻辑和对象的回收逻辑类似，内存不足的情况下，如果字符串常量池不被使用就可以被回收；方法区中类的元信息回收逻辑更复杂一些，**移动到堆后，就可以利用对象的垃圾回收器，对常量池进行回收。**

**2.让方法区大小更可控，** 一般在项目中，类的元信息不会占用特别大的空间，如果字符串常量池在方法区中，会让方法区的空间大小变的不可控。

**3.intern方法的优化：** JDK6版本中的intern()方法会把第一次遇到的字符串实例复制到永久代的字符串常量池中，JDK7及以后版本中由于字符串常量池在堆上，就可以进行优化：**字符串保存在堆上，把字符串的引用放入字符串常量池，减少了复制的操作。**

# 4 HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程

## 4.1  对象的创建

**Step1、类加载检查**

当虚拟机遇到一条new指令，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，**并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。**

**Step2、分配内存**

**类加载检查**通过后，接下来虚拟机将为新生对象 **分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来

分配方式：**1、指针碰撞：** 用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。

**2、空闲链表：** 虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。

### 内存分配并发问题

**CAS+失败重试**，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。

**TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。

**Step3、初始化零值**

虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）

**Step4、设置对象头**

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。

**Step5、执行init方法**

初始化完成。

### 对象的访问定位

直接指针方式：reference存的就是对象的地址。

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%201.png)

# 5 类的生命周期

加载 —> 连接（验证、**准备、解析**）—> 初始化 —> 使用 —> 销毁   

1、**加载** 不同的渠道 以二进制流的方式获取字节码信息 方法区（InstanceKlass）堆区（java.lang.class）

2、**验证：** 文件格式、元数据、字节码、符号引用验证

3、**准备：** 给静态变量赋初值 **（有final修饰实际值，无则是0/null）**

**解析：** 将常量池中的符号引用替换成指向内存的直接引用。符号引用就是在字节码文件中使用**编号**来访问常量池中的内容。直接引用不再使用编号，而是使用**内存中的地址**进行具体数据的访问。

**4、初始化阶段：** 执行静态代码块中的代码、静态变量赋值（与2区别）、执行字节码文件中的clinit部分的字节码指令(就是类中的代码块{})。

**5、类的卸载（条件非常严格）** 类的所有实例对象被回收，加载该类的加载器被回收、该类对应的java.lang.Class对象没有在任何地方被引用。

# 6 类加载器

## 6.1 类加载器定义

类加载器负责在类的加载过程中将**字节码信息**以 **流** 的方式**获取并加载到内存中**

分类：

1、Java虚拟机底层源码实现：**启动类加载器（Bootstrap）** JDK9之前用C++编写，JDK9之后使用Java编写。**加载Java中最核心的类**

2、Java代码中实现：

**扩展类加载器（Extension Class Loader）** JDK9之后由于采用了模块化，改名Platform平台类加载器。**允许拓展Java中比较通用的类。**

**应用程序类加载器（Application Class Loader）默认加载为应用程序classpath下的类。**

**自定义类加载器**：**允许用户自行实现类加载器的逻辑，可以从网络、数据库等来源加载类信息，** 自定义类加载器需要继承自ClassLoder抽象类，重写findClass方法。

## 6.2 双亲委派机制

双亲委派机制的核心是解决**一个类到底由谁加载的问题**

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/278db7d1-b592-4c7c-a885-5eb6d00c6f50.png)

**每一个类都有一个父类加载器，形成了从下到上的层级结构，当一个类加载器接收到加载类的任务时，会向上查找是否加载过，再由顶向下进行加载。**

**作用：1、保证类加载的安全性**

**2、避免重复加载**

## 6.3 打破双亲委派机制

classLoader中包含了4个核心方法

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%202.png)

**重写LoadClass方法，将其中的双亲委派机制代码全部去掉**，重写findClass实现类加载器加载，不会破坏双亲委派机制。

👆自定义类加载器，还有其他方法：线程上下文类加载器、Osgi框架的类加载器。

### 什么情况下，需要打破双亲委派机制？

- **实现SPI机制**

**问题：** 核心类库需要加载第三方实现的类（如JDBC驱动），但这些实现类由应用类加载器（子加载器）提供，而核心类由启动类加载器（父加载器）加载。**按照双亲委派规则，父加载器无法直接访问子加载器的类。**

**解决：** 通过线程上下文类加载器（Thread Context ClassLoader），**让父类加载器主动请求子类加载器加载实现类。**

示例：JDBC驱动加载时，DriverManager（由Bootstrap加载器加载）通过线程上下文类加载器获取应用类加载器，加载com.mysql.jdbc.Driver。)  核心类 DriverManager 由 Bootstrap 加载 ，JDBC 驱动实现类（如 MySQL Driver）由应用类加载器加载，按照双亲委派模型，DriverManager 无法直接加载 com.mysql.jdbc.Driver。

- **实现模块化和热部署**

**问题：** 在需要动态加载或卸载模块的场景（如Tomcat、OSGi框架），**不同模块可能需要隔离类环境或加载同一类的不同版本。**

**解决：** 每个模块使用独立的类加载器，优先加载自己路径下的类（打破双亲委派）。

示例：Tomcat：每个Web应用使用独立的WebAppClassLoader，优先加载WEB-INF/classes和WEB-INF/lib中的类，而非委托给父加载器（SharedClassLoader）。【下面图也清晰的展示了：一般都是由父类加载 → 由自己加载，Tomcat打破之后由自己加载 → 由父类加载】

## Tomcat自定义类加载器（重要）

Tomcat中，实现了一套自定义的类加载器

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%203.png)

1、**common 类加载器** 主要加载tomcat自身使用以及应用使用的jar包，默认配置在catalina.properties文件中。（它的父类加载器是应用程序类加载器）

2、**catalina 类加载器** 主要加载tomcat自身使用的jar包，**不让应用使用**

默认配置在catalina.properties文件中。**这个类加载器不会自动创建的，得你在相应位置去配置。**

catalina类加载器默认是不创建出来的**，server.loader = 默认配置为空**，为空时catalina加载器和common加载器是同一个，如果不为空的话，则会创建出catalina类加载器，将来会去加载这个目录下对应的jar包。  

3、**shared 类加载器** 主要加载应用使用的jar包，不让tomcat使用，默认配置在catalina.properties文件中。这个和catalina类加载器一样的，**不会自动创建，得你主动在相应位置上去配置。**

shared.loader = 默认配置为空，为空时shared加载器和common加载器是同一个。👆和catalina加载器相同。

**为什么每个应用会拥有一个独立的 ParallelWebappClassLoader 类加载器呢？**

**同一个类加载器，只能加载一个同名的类。** 两个应用中相同名称的类都必须要加载。所以为了能加载不同应用程序中同名的类，Tomcat底层让每个应用都去拥有一个独立的ParallelWebappClassLoader。

**ParallelWebappClassLoader的执行流程：**

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%204.png)

交给父类加载器处理实际上走的就是双亲委派机制，没有开启代理的话，实际上打破了双亲委派机制 **（为了保证每个应用中的类都可以独立被加载，不要出现相同名字的类加载冲突），开启代理后的这条路就打破了双亲委派机制。**

# 7.如何判断堆上的对象有没有被引用？

1、引用计数法   

2、可达性分析法  **Java虚拟机使用可达性分析法** 

**引用计数法：** 为每一个对象维护一个引用计数器，当对象被引用时+1，取消时-1，计数为0时回收

缺点：1、每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响

      2、存在循环引用的问题，当A引用B，B引用A会出现对象无法回收的问题

**可达性分析法：** 从某个到 **GC Root对象是** 可达的，对象就不可被回收（在引用链上）

## GC Root一般有哪些？

**1、线程Thread对象**

**2、系统类加载的 java.lang.class 对象**

**3、监视器对象，用来保存同步锁synchronized关键字持有的对象**

**4、本地方法 调用时 使用的全局对象**

在JVM中，通过JNI（Java Native Interface）本地方法调用时使用的全局对象有其特殊的生命周期管理方式。

## JVM中都有哪些引用类型？

**1、强引用**

JVM中默认的引用关系就是强引用（可达性算法描述的对象引用）。只有当对象不再有任何强引用时，才能被GC回收。

**2、软引用**

用于描述**有用但非必需**的对象。如果一个对象中只有软引用关联到它。

如果内存充足，软引用对象可以一直存在。

当程序中内存不足时，JVM会在OOM之前清理掉所有的软引用对象。主要在**缓存框架**中使用，

**3、弱引用**

用于描述非必需对象，比软引用更弱，**无论内存是否充足**，GC都会回收弱引用对象。

主要在**ThreadLocal**中使用。

**4、虚引用**

（幽灵引用）不能通过虚引用对象获取到包含的对象，虚引用唯一的用途是**当对象被垃圾回收器回收时可以接收到对应的通知（主要用来跟踪对象被GC回收的状态）**。

用于资源清理或对象回收的监控

**5、终结器引用**

对象需要被回收时，终结器引用会 **关联对象并放置在Finalizer类中的引用队列** 中，在稍后由Finalizer-Thread线程从队列中获取对象，然后执行对象的 **finalize方法** ，在对象第二次被回收时，该对象才真正被回收。

## ThreadLocal的使用

ThreadLocal是这样去保存对象的：

1、在每个线程中，存放了一个**ThreadLocalMap对象**，本质上就是一个数组实现的哈希表，里面存放多个Entry对象。

2、每个 **Entry对象（key）** 继承自弱引用，内部存放ThreadLocal对象。同时用强引用，引用保存ThreadLocal对应的value值。

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%205.png)

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%206.png)

不再使用ThreadLocal对象时，threadlocal = null；由于是弱引用，那么在垃圾回收之后，ThreadLocal对象就可以被回收。

此时还有Entry对象和value对象没有能被回收，所以在ThreadLocal类中的set、get、remove方法中，在某些特定条件满足的情况下，会主动删除这两个对象。

合理的做法是手动调用remove方法进行回收，然后再将threadLocal对象的强引用解除。

### 为什么要这么设计（键是弱引用，值是强引用）？

为了**在内存泄漏风险和功能可用性**之间取得平衡。

**1、键使用弱引用的原因**

**防止 ThreadLocal 实例无法回收：** 如果键是强引用，即使开发者将 ThreadLocal 实例的强引用置为 null **（例如 threadLocal = null）**，由于 ThreadLocalMap 中的键仍然持有对该实例的强引用，会导致 ThreadLocal 实例无法被垃圾回收，从而引发内存泄漏。

**2、值使用强引用的原因**

**确保值的可用性：** 如果值也是弱引用，当 ThreadLocal 实例被回收后，对应的值可能被过早回收（例如，即使开发者仍然需要这个值）。强引用可以保证值在显式调用 remove() 或线程终止前始终可用。

# 8.垃圾回收算法

## 8.1 常见的垃圾回收算法

**1、标记清除算法：** 标记阶段 —→ 清除阶段 **（清除没有被标记的）**

**从根节点开始遍历所有可达对象，并将其标记为“存活”。随后扫描整个堆，将未标记的对象视为垃圾并进行回收。**

缺点：1、碎片化问题 2、分配速度慢

**2、复制算法** （from空间、to空间；复制结束后，名称相互转换）

缺点：内存使用效率低

**3、标记整理算法（标记清除算法的升级）**

标记阶段（可达性分析算法）——>整理阶段：**将存活对象移动到堆的一端。清理掉存活对象的内存空间。**

缺点：**整理阶段的效率不高**

---

**标记清除和标记整理有什么区别？**

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%207.png)

---

**4、分代垃圾回收算法（重要）**

过程：

Eden区满，会触发年轻代的GC，Minor GC **（s0、s1相当于复制算法中的from区，to区）**

每次MinorGC会记录年龄，年龄到要求了，会放入老年代

老年代空间不足，会先尝试Minor GC,如果还是不足，触发Full GC，对整个堆进行回收

如果依旧不行，会抛出OutOfMemory的异常

分代垃圾回收的优点：

1、可以调整老年代和新生代的比例，提高内存的利用率和性能。

2、老年代和新生代可以使用不同的垃圾回收算法，灵活度高

3、 分代的设计中，只允许回收新生代（minor gc）,由垃圾回收引起的停顿时间减少

## 8.2 常用的垃圾回收器

年轻代+老年代，是有组合的；垃圾回收器主要是为了实现垃圾回收算法的。

### Serial垃圾回收器+SerialOld垃圾回收器

**Serial = 串行**，每次它就是一款单线程收集器。Serial工作在新生代，Serial Old工作在老年代（一般作为CMS并发收集失败后的备选回收方案）

在垃圾回收期间，它会STW，stop the world，**当它工作时，用户线程就得暂停，等它工作完成时，用户线程才允许继续工作。**

- **参数：** -Xx : +UseSerialGC    -Xx : +UseSerialOldGC
- **特点：** 1、收集效率高：因为在使用时，将所有的线程暂停，所以在回收过程中，不会产生一些对象的引用变更、浮动垃圾
    
    2、多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于较长时间等待。
    

### PS Parallel Scavenge 多线程收集器

为了让STW时间减少，使用 **多线程进行回收** 。默认的线程数和CPU核数相同。多线程并行，关注的是**系统的吞吐量**，具备**自动调整堆内存大小**的特点 ，年轻代**复制算法**，老年代**标记-整理算法**，JDK8默认

![屏幕截图 2025-02-09 132030.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-02-09_132030.png)

优点：**吞吐量高，（多线程，STW相对少点）** 且手动可控，为了提高吞吐量，虚拟机会动态调整堆参数。
缺点：不能保证单次的停顿时间。

### ParNew

**和PS一样，** 都是多线程进行回收，不过它主要和CMS收集器配合使用。 ParNew:年轻代，本质上是对Serial在多CPU下的优化，多线程回收。 

### CMS（问的多！）

在回收效率和用户体验上做一个平衡。基本实现了用户线程和垃圾回收线程同时工作。

CMS（Concurrent Mark Sweep）垃圾回收器:（JDK9之后就不再使用了，主要还是G1垃圾回收器）

- 垃圾回收过程

Step1、**初始标记：** 暂停所有用户线程，只标记GC Root直接引用的对象。（STW很短）

Step2、**并发标记：** GC线程和用户线程同时工作，GC从GC Root开始遍历整个对象图。

Step3、**重新标记**：因为上个过程是并发进行的，所以有些对象是在标记过程中新产生的，导致没有标记上，所以这个过程进行修正，将这些漏网之鱼都标记上（STW很短）

Step4、**并发清理：** 开始对三色标记之后需要处理的对象进行清理，这个过程也是并发执行的。

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%208.png)

CMS垃圾回收器关注的是系统的暂停时间，**允许用户线程和垃圾回收线程在某些步骤中同时执行（标记阶段和清理阶段同时进行），减少了用户线程的等待时。**

缺点：1、CMS使用了标记清除算法，在垃圾回收结束之后会出现 **大量的内存碎片，** CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停。

2、产生的 **“浮动垃圾”**（并发清理的过程中，用户也会产生新的对象），不能做到完全的垃圾回收。

3、如果老年代内存不足，无法分配对象，CMS就会退化成Serial Old单线程回收老年代。

4、并发阶段会影响用户线程执行的性能。

### G1（Garbage First 垃圾回收器）

满足最小的STW而且还能控制停顿时间。年轻代+老年代 **复制算法（不会产生内存碎片）**、G1的整个堆会被划分成多个**大小相等**的区域，**区域不要求是连续的。**

![屏幕截图 2025-02-09 143738.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-02-09_143738.png)

G1垃圾回收器在回收的时候，会选择其中的某一些区域来进行回收，可以更有效的去控制这个停顿时间。（JDK9之后是默认的不需要打开的）**这些区域并不是固定的，比如说现在是Eden区，可能将来就变成了Old区。** 

**回收过程：**

**Step1、初始标记：** 暂停所有用户线程，记录GC ROOT 直接引用的对象

**Step2、并发标记：** GC线程和用户线程同时工作，GC从gc root开始遍历整个对象图

**Step3、最终标记：** 因为上个过程是并发进行的，所以有些对象是在标记过程中新产生的，导致没有标记上，所以这个过程进行修正

**Step4、筛选回收：计算每个 region 的回收成本**，并**按照回收成本进行排序，然后按照用户期望的停顿时间进行计算：**应该回收哪些region，才能满足停顿期望。

G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。

**优点：**

1、支持巨大堆空间回收，有较高的吞吐量

2、支持多GPU**并行垃圾回收**

3、允许用户设置最大暂停时间

**缺点：**

**1、CPU资源消耗：** G1的并发标记阶段需与应用程序线程并行运行，可能占用较多的CPU资源，导致应用吞吐量下降

**2、Region大小对性能的影响：** G1将堆划分为多个固定大小的Region,可能导致碎片化风险，频繁分配/释放大对象可能导致Region碎片化，降低内存利用率。

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%209.png)

# 9.常见的JVM参数(JVM调优的参数)

JVM调优的位置：在启动Java应用时，通过命令行直接指定JVM参数

### 参数1：-Xmx 最大堆内存   -Xms 最小堆内存

-Xmx设置的是最大堆内存 ，但是由于程序是运行在服务器或者容器上，计算可用内存时，要将元空间、操作系统、其他软件占用的内存排除掉

-Xms设置的是最小堆内存，一般是指程序启动完之后，默认的初始内存大小

-X是通用的，mx表示**m**emory ma**x**imum，ms表示**m**emory **s**tart

**建议将-Xmx和-Xms设置一样大，运行过程中不再产生扩容开销**

### 参数2：-XX：MaxMetaspaceSize = 值

**参数指的是最大元空间大小，** 默认值比较大，如果出现元空间内存泄漏会让操作系统可用内存不可控，建议根据测试情况设置最大值

### 参数3：-Xss 值

栈内存的大小，如果我们不指定栈内存的大小，JVM将创建一个具有默认大小的栈

ss表示**s**tack **s**ize

### 参数4：-Xmn 年轻代的大小

设置年轻代的大小，默认值是整个堆的1/3

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%2010.png)

mn表示**m**emory **n**ew

### 参数5：GC日志记录

生产环境上，或者其他要测试GC问题的环境上，一定要配置上打印GC日志的参数。

```bash
# 必选
# 打印基本 GC 信息
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
# 打印对象分布
-XX:+PrintTenuringDistribution
# 打印堆数据
-XX:+PrintHeapAtGC
# 打印Reference处理信息
# 强引用/弱引用/软引用/虚引用/finalize 相关的方法
-XX:+PrintReferenceGC
# 打印STW时间
-XX:+PrintGCApplicationStoppedTime

# 可选
# 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint
-XX:+PrintSafepointStatistics
-XX:PrintSafepointStatisticsCount=1

# GC日志输出的文件路径
-Xloggc:/path/to/gc-%t.log
# 开启日志文件分割
-XX:+UseGCLogFileRotation
# 最多分割几个文件，超过之后从头文件开始写
-XX:NumberOfGCLogFiles=14
# 每个文件上限大小，超过就触发分割
-XX:GCLogFileSize=50M
```

### JVM调优（常问）

JVM调优很不常见：如果你的JVM出现了很大的GC压力，首先要从代码上去优化，而不是调整JVM，调整JVM可能会出现很多问题：**不可维护、不可拓展等。**

常见调优策略：

**1、固定堆的大小：** 一般我们需要把JVM的堆内存大小固定，使用参数 **(最大堆和最小堆一般设置为一样的)**

```bash
-Xms 2048M -Xmx 2048M
```

**2、设置Region大小**

Region的大小一般都是2的幂，从1MB → 32MB。在Heap比较小时，我们可以把Region设置的小一点，例如2MB，4MB；反之，就大一些。

（控制Region的数量）

**3、设置最大停顿时间**

G1最大的特点就是停顿预测模型，G1有个默认的停顿时间是200ms，我们可以设置一个预期的停顿时间

```bash
-Xx:MaxGCPauseMillis = 100
```

对于一些延迟比较敏感的场景，可以适当减小这个时间。

**4、设置标记线程和回收线程**

就是设置一些并行回收线程数和并发标记线程数。

# 10.堆（Heap）区域细分

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%2011.png)

堆（Heap）是Java虚拟机最大的内存区域，用于存放几乎所有的对象实例和数组。为了更有效的管理和回收内存，JVM中的堆通常会被进一步细分为几个不同的区域

## 10.1 年轻代（**Young Generation**）

年轻代主要用于存放新创建的对象。绝大多数对象在创建后很快就会变得不可达（即不再被引用），因此它们会被快速回收。

### 10.1.1 Eden区

新创建的对象首先被分配到 Eden 区。当 Eden 区满时，会触发一次 Minor GC（小型垃圾回收），存活的对象会被移动到 Survivor 区。

在 Minor GC 后，存活的对象会被复制到 Survivor 区。**经过多次 GC 后仍然存活的对象会被移动到老年代（Old Generation）。**

### 10.1.2 Survivor区

Survivor 区有两个，通常称为 `Survivor 0` 和 `Survivor 1`，也称为 `From Space` 和 `To Space`。它们轮流进行对象的复制和压缩。

---

默认的Eden:S0:S1 = 8:1:1 (通过-Xx:SurvivorRatio = 8配置)是经过大量实践验证的优化比例，核心逻辑如下：

1、Eden区占80%，大部分对象在Eden区分配后很快死亡，较大的Eden区减少了Minor GC的频率。**（Eden区过小会导致频繁触发Minor GC，增加GC停顿时间）**

2、Survivor区占20%，Survivor区过大的话会浪费空间 **（大多数对象根本活不到晋升阶段）**

---

## 10.2 老年代（Old Generation）

### 长期存活对象将进入老年代

用于存放生命周期较长的对象。通常这些对象在经过多次 Minor GC 后仍然存活。老年代的空间较大，遇到内存不足时会触发 Major GC（或 Full GC），回收效率较低。

新生代年龄增加到一定程度就会晋升到老年代中（默认为15岁）。可以通过参数-XX：MaxTenuringThreshold来设置，不过设置的值应该在0-15。

因为记录年龄的区域在对象头中，**这个区域的大小通常是 4 位。** 这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。

### 大对象直接进入老年代

可以使用参数调节这一行为，相当于一种优化策略。

大对象就是需要大量连续内存空间的对象（数组、字符串），旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。

## 10.3 方法区（Method Area，不属于堆）

方法区是 JVM 规范中定义的一种内存区域，用于**存放类的结构信息，包括常量池、字段和方法的描述等。**

当虚拟机要使用一个类时，它需要读取并解析Class文件获取相关信息，再将信息存入到方法区。**方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。**

### 方法区和永久代/元空间是什么关系呢？

方法区和永久代以及元空间的关系很想 **Java接口和类** 的关系。

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%2012.png)

在 Java 8 之前，方法区通常与永久代（PermGen）对应；在 Java 8 及其之后，方法区与元空间（Metaspace）对应。**元空间相当于永久代的升级版本。**

- 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
- 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

### 方法区中的方法的执行过程？

1、解析方法调用 ：JVM会根据方法的符号引用找到实际的方法地址（如果之前没有解析过的话）

2、栈帧创建 ：在调用一个方法前，JVM会在当前线程的java虚拟机栈中为该方法分配一个新的栈帧

3、执行方法：执行方法内的字节码指令

4、返回处理：方法执行完毕后，可能会返回一个结果给调用者。

### String 保存在哪里？

String 保存在**字符串常量池中**，不同于其他对象，**它的值是不可变的，且可以被多个引用共享**

### ( 经典问题 )String s = new String(”abc”)执行过程中分别对应哪些内存区域？

new 指令是创建一个类的实例对象并完成加载初始化的，因此创建的字符串对象是在堆内存上。

String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个字符串常量。在首次构建这个对象时 **，JVM拿字面量“abc”去字符串常量池试图获取其对应String对象的引用。于是在堆中创建了一个“abc”的String对象，并将其引用保存到字符串常量池中，然后返回；**

**如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及new String这个实例对象。如果abc这字符串常量存在，则只会创建一个对象。**

# 11. JVM常见问题与解决工具

## 11.1 Full GC产生原因以及解决策略？

**Full GC的常见原因**

- **内存泄露：** 未释放的对象持续累积。
- **对象晋升过快：** Survivor区过小 或 晋升阈值设置不合理。

**Full GC的解决方法**

- **诊断与监控** 启用GC日志分析。添加JVM参数，关键指标：Full GC频率、耗时、回收前后堆内存变化、晋升失败日志。
- **内存泄露处理**  识别泄露对象：通过Heap Dump分析对象的引用链，找到未释放的根源（如ThreadLocal未清理、全局缓存未过期）
- **JVM参数调优** 调整堆大小和分区比例，优化晋升策略

## **11.2 如何解决内存泄漏问题**

内存泄漏（memory leak）：在Java中不再使用一个对象，但是该对象依然在GC Root 的引用链上，这个**对象就不会被垃圾回收器回收，这种情况称之为内存泄漏**。

少量的内存泄漏可以容忍，但如果发生持续的内存泄漏，就像雪球越滚越大，不管有多大的内存迟早会被消耗完，最终导致的结果就是 **内存溢出。**（内存溢出是指Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发OOM）

### **解决内存泄漏的步骤：**

**1、发现：** 通过监控工具尽可能的早的发现内存慢慢变大的现象

**2、诊断原因：** 通过分析工具，诊断问题的产生原因，定位到出现问题的源代码

**3、修复问题：** 修复源代码中的问题

**4、测试验证：** 在测试环境验证问题解决，最后发布上线

诊断 → 生成内存快照 **（需要在堆内存溢出时，将整个堆内存保存下来，生成内存快照文件）**

生成方式有两种：

1、内存溢出时自动生成，添加生成内存快照的Java虚拟机参数：-XX:+HeapDumpOnOutOfMemeoryError错误时，自动生成hprof快照文件

2、jmap命令导出

诊断———>使用MAT打开hprof文件，并选择内存泄漏检测功能，MAT会自行根据内存快照中保存的数据分析内存泄漏的根源

## 11.3 JDK监控和故障处理工具总结

### JDK命令行工具

**//这里注意jps和jmap的区别**

**`jps` (JVM Process Status）: 类似 UNIX 的 `ps` 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；**

**`jstat`**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;

**`jinfo`** (Configuration Info for Java) : 实时地查看和调整虚拟机各项参数。

**`jmap`** **(Memory Map for Java) : 生成堆转储快照;**

**`jhat`** (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。JDK9 移除了 jhat；

**`jstack`** (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。

### JDK可视化分析工具

### JConsloe:Java监视与管理控制台

JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。

在控制台输入`jconsole`命令启动或者在 JDK 目录下的 bin 目录找到`jconsole.exe`然后双击启动。

![image.png](Java%20JVM%20d170aaf652a54b18a44ce90020059075/image%2013.png)
