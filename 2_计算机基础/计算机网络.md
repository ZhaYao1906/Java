# 计算机网络

# 1. 基础知识

## 1.1 为什么网络要分层？—针对TCP/IP分层模型

- **各层之间相互独立，** 各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。
- **提高了灵活性和可替换性，这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。**
- **大问题化小**：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化 。

### TCP/IP模型分层

- **应用层**

HTTP、FTP、Talnet、DNS、SMTP等 应用层只需要专注于为**用户提供应用功能。**

- **传输层 TCP/UDP**

传输层为应用层提供网络支持的，**并不是指将数据从一个设备传到另一个设备。**

当传输层的数据包大小**超过MSS（TCP最大报文段长度）**，**就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送一个分块，** 而不用重新发送整个数据包。在TCP协议中，我们把每个分块称为一个TCP段。

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image.png)

**端口 :** 当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。

- **网络层**

**实际的传输功能，** 从一个设备传输到另一个设备，**传输层并不是将数据从一个设备传到另一个设备，实际的传输功能交给网络层来处理。**

IP协议：IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文。如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。

功能：**IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**。

- **网络接口层**

在IP头部的前面加上MAC头部，并封装成数据帧（Data Frame）发送到网络上。

存在意义：IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。

以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。

**网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。**

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%201.png)

## 1.2 键入网址到网页显示，期间发生了什么？

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/17c7f04e-4232-480c-a9b3-405c2f271cb1.png)

**step1、在浏览器中输入指定网页的URL，浏览器的第一步工作是解析URL**

对 URL 进行解析，从而生成发送给 Web 服务器的请求信息。**（提取出协议（HTTP或HTTPS）、域名、端口号（默认为80或443）和路径）**

对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来 **生成HTTP请求。**

**step2 DNS协议：真实地址查询，把域名转换成IP地址**

DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名（www.server.com），而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先**把域名转换成相应 IP 地址。**

浏览器 **首先检查本地缓存（如浏览器缓存、操作系统缓存）是否有该域名的 IP 地址**。如果缓存中没有，浏览器会向配置的 DNS 服务器发送查询请求。**DNS 服务器递归查询，最终返回域名对应的 IP 地址。**

**step3 建立TCP 连接：** 浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 **Web 服务器发起 TCP 连接请求，** 通过 TCP **三次握手** 建立好连接。

**step4 远程定位——IP**：TCP 模块在执行连接、收发、断开等各阶段操作时，**都需要委托 IP 模块将数据封装成网络包发送给通信对象。**

**step5 数据链路层地址MAC—两点传输**

建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议， **通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议**，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此**确定目标的物理地址，找到目的MAC地址。**

在 MAC 包头里需要 **发送方 MAC 地址** 和 **接收方目标 MAC 地址**，用于两点间传输。

---

**注：被拷打了 → 判断目标网络位置：
源主机通过子网掩码计算目标IP是否在同一局域网：**

**1、同一局域网：直接发送ARP请求获取目标MAC。**

**2、不同局域网：触发网关转发机制。**

Step1、源主机将数据包发送至 默认网关（Default Gateway）（即本地路由器的接口IP，如 192.168.1.1）。**如何获取网关的MAC地址？→ 通过 ARP协议 查询网关IP对应的MAC地址（与普通ARP流程相同）。**

Step2、若下一跳MAC未知，发送ARP请求获取下一跳路由器MAC（在对应接口的局域网内）。

Step3、逐跳转发：每个路由器重复上述解封装-路由-重新封装过程。

Step4、最后一跳路由：目标网络的路由器广播ARP请求目标主机MAC。目标主机响应后，路由器完成最终数据帧投递。

---

**step6 传输—网卡**

网络包只是内存中的的一串二进制数字信息，我们需要将**数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。**

**step7 交换机**

电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。

**step8 路由器**

网络包经过交换机之后，现在到达了**路由器**，并在此被转发到下一个路由器或目标设备。

---

**交换机与路由器的区别**

因为**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；

而**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。

---

**step9 服务器**

数据包抵达服务器后。

1、服务器会先扒开数据包的 **MAC 头部**，查看**是否和服务器自己的 MAC 地址符合**，符合就将包收起来。

2、接着继续扒开数据包的 IP 头，发现 **IP 地址符合**，根据 IP 头中协议项，知道自己上层是 TCP 协议。

3、扒开 TCP 的头，里面有**序列号，**需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里，返回给客户端。

**step10 浏览器渲染**

浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。

### 如果一个页面跳转慢，该怎么处理？（比较综合）

针对页面跳转慢的问题，我们可以将整个链路拆解为 **前端 → 网络 → 后端 → 基础设施**

- **前端环节**

问题定位工具 ：Chrome DevTools - Network 面板

 优化措施 ：(1) 资源加载优化  (2) 渲染优化

- **网络环节**

问题定位工具 ： WebPageTest：多地域测试，查看不同地区的 DNS/TCP/TLS 时间。

Ping/Traceroute：诊断网络链路延迟和丢包。

优化措施 ：（1）DNS 优化 ：DNS 预解析（2）TCP/TLS 优化：开启 HTTP/2

- **后端环节**

问题定位工具：（1）APM 工具（如 SkyWalking、New Relic）：追踪 API 调用链，定位慢 SQL、外部服务延迟。（2）数据库慢查询日志

优化措施：(1) API 性能优化：缓存策略、异步处理 （2）数据库优化：索引优化、分库分表

- **基础设施环节**

**硬件升级** 升级云服务器规格（如 AWS 从 t3.medium 升级到 c5.large）。

**存储优化**：使用 NVMe SSD 替代 HDD。

---

## 打开/关闭一个网页发生了什么？

打开网页就上面那个

**关闭网页：**

**1、传输层：释放连接**

TCP四次挥手：

1、客户端 → 服务器：发送 FIN（seq=u），进入 FIN-WAIT-1。

2、服务器 → 客户端：回复 ACK（ack=u+1），进入 CLOSE-WAIT；客户端进入 FIN-WAIT-2。

3、服务器 → 客户端：发送 FIN（seq=v），进入 LAST-ACK。

4、客户端 → 服务器：回复 ACK（ack=v+1），进入 TIME-WAIT（等待 2MSL 后关闭）。

目的：确保双方数据收发完毕，防止残留报文干扰新连接。

**2、资源清理**

浏览器释放资源

关闭Socket连接，清理内存中的DOM、缓存等。若页面使用WebSocket或长连接，触发额外关闭逻辑。

## 1.3 DDOS攻击

DDOS（Distributed Denial of Service，分布式拒绝服务）攻击是一种试图使目标系统（如服务器、服务或网络）不可用的攻击方式。它通过让**大量的虚假流量超载目标系统，导致合法用户无法访问该系统。（疯狂访问，导致正常的访问无法工作！！！）**

### DDOS攻击类型：

1. **流量型攻击（Volume-Based Attacks）**：
    
    **ICMP洪泛攻击（ICMP Flood）**：发送大量的ICMP请求（如Ping）以消耗目标的带宽。
    
    **UDP洪泛攻击（UDP Flood）**：发送大量的UDP数据包，占用目标的网络带宽和资源。
    
2. **协议型攻击（Protocol Attacks）**：
    
    **SYN洪泛攻击（SYN Flood）**：通过发送大量的SYN请求来**占用服务器的连接资源。**
    
    **Ping of Death**：发送超大ICMP包导致目标系统崩溃。
    
3. **应用层攻击（Application Layer Attacks）**：
    
    **HTTP洪泛攻击（HTTP Flood）**：发送大量的HTTP请求使Web服务器超负荷。
    
    **Slowloris攻击**：通过保持大量的HTTP连接使服务器资源耗尽
    

**如何避免SYN Flood攻击？**

- **减少SYN-ACK重试次数 :** 减少SYN-ACK重试次数可加快释放半连接资源。
- **负载均衡和CDN :** 负载均衡和CDN能分散流量，减轻单点压力。
- **TCP连接速率限制 :** 限制单个IP的连接速率，防止大量SYN请求。

## **1.4 会话技术**

会话：用户打开浏览器，访问web资源，会话建立，直到有一方断开连接，会话结束。

会话跟踪：一种维护浏览器状态的方法，服务器需要识别 **多次请求是否来自于同一浏览器** ，以便 **在同一次会话的多次请求间共享数据。**

### **1.4.1 Cookie**

Step1、第一次请求,服务器在处理客户端请求时，生成一个或多个Cookie。

Step2、设置Cookie，服务器通过 **HTTP响应头set-cookie** 将Cookie发送给客户端。

Step3、客户端（通常是浏览器），接收到Cookie，将Cookie存在本地中

Step4、客户端下一次发送请求的时候，会自动将之前存储的Cookie通过HTTP请求头发送给服务器。

---

**缺点：**

**1、不安全，用户可以自己禁用Cookie**

**2、Cookie不能跨域（协议、IP/域名，端口有一个维度不同，即为跨域）**

### **1.4.2 Session**

相比较Cookie,存储在服务端，安全。

Step1、服务器在处理客户端请求时，检测服务器中有没有当前的Session ID，没有的话，服务器生成一个**唯一的Session ID**

Step2、服务器发送Session ID 给客户端，HTTP响应头为set-cookie（对，没错还是用的set-cookie）。

Step3、客户端将Session ID存储在浏览器的Cookie中。

Step4、客户端在后续请求中会自动将Session ID通过Cookie请求头发送给服务器。

**缺点：**

**1、在服务器集群的环境下，无法直接使用Session**

**2、底层基于Cookie，还是会有Cookie的缺点。**

- **如果在服务器集群的环境下使用Session,设计方案？(被问过不知道多少次了)**

**1、Session复制：**将 Session 数据**在所有服务器节点之间**复制，确保每个服务器都有一份完整的 Session 数据。

**2、集中式 Session 存储**：将 Session 数据集中存储在一个共享的外部存储系统中（redis），所有服务器节点都从该存储中读取和写入 Session 数据。

**3、粘性 Session（Sticky Session）：通过负载均衡器（如 Nginx、HAProxy）将同一用户的请求始终分发到同一个服务器节点。（第三点老是忘）**

### **1.4.3 令牌技术 JWT**

JWT（JSON Web Token）是一种基于 JSON 的开放标准（RFC 7519）实现的令牌，用于在各方之间安全地传输信息。

- **结构**

**Header（头）**

Header 通常包含两个部分：**令牌的类型（JWT） 和 所使用的签名算法**（如 HMAC SHA256 或 RSA）。

**Payload（有效载荷）**

Payload 部分包含声明（claims），**声明是关于实体（通常是用户）和其他数据的陈述**。声明分为三类：

**Signature（签名）**

为了确保令牌未被篡改，**签名部分将 Header 和 Payload 的组合使用指定的算法加密，并添加一个密钥。**

- **缺点**

**1、令牌大小过大**  JWT 通常比传统的会话令牌大，因为它包含了所有必要的用户信息和元数据（如头部、载荷和签名）。在网络传输中，较大的令牌会增加带宽消耗，尤其是在移动网络环境下。

**2、无法即时撤销** JWT 是无状态的，服务器在签发后无法直接撤销或使其失效，除非等待其自然过期。

---

**之前被拷打过：针对这个问题，有什么解决方法？**

**方法一：缩短令牌有效期 + 刷新令牌  设置较短的Access Token 有效期（15min）**

**方法二：服务端令牌黑名单（BlackList）** 在服务端维护一个黑名单（Redis），存储被吊销但未过期的JWT。每次请求时，校验JWT是否在黑名单中。

**方法三：结合时间窗口和版本号** 在JWT的PayLoad中加入version字段，用户关键操作（如修改密码）时递增版本号，校验时对比令牌版本号与数据库当前版本。

---

**3、安全性依赖签名**  JWT 的安全性依赖于签名算法。如果签名密钥泄露或算法被破解，整个系统的安全性将受到威胁。需要严格管理签名密钥，并定期更新密钥。

**4、载荷数据暴露**  JWT 的载荷（Payload）是 Base64 编码的，虽然可以加密，但通常是不加密的。如果 JWT 被截获，攻击者可以解码并查看载荷中的数据，可能导致敏感信息泄露。

- **优点**

1、JWT令牌基于json，非常方便解析。

2、可以**在令牌中自定义丰富的内容，易扩展。**

3、通过非对称加密算法以及数字签名技术，JWT令牌防止篡改，安全性高。

- **跨域问题**

JWT本身并不直接解决跨域问题，但可以间接帮助实现跨域身份验证。

跨域问题的本质是**浏览器的同源策略（Same-Origin Policy）** 限制了跨域请求，而JWT令牌是一种无状态的令牌机制，它的设计特性使其在跨域场景中更容易被使用。

JWT通常通过以下方式在跨域请求中传递，避开传统Cookie的限制：**通过HTTP Header（Authorization）**

- **客户端在请求头中添加JWT**

```java
GET /api/data HTTP/1.1
Authorization: Bearer <JWT_TOKEN>
```

- **服务端在响应头中设置`Access-Control-Allow-Headers: Authorization`。**

## **1.5 其他知识**

- 按照覆盖的地理范围，计算机网络可以分为：**局域网、城域网、广域网**

局域网 一般用于微型计算机或工作站，城域网 多采用以太网技术，作用范围一般是一个城市，广域网 是长距离运输数据

- 建立计算机网络的主要目的：**资源共享和在线通信**
- 最基本的网络拓扑结构：**总线型、环形、星型**
- IP互联网中，路由通常分为 **静态路由** 和 **动态路由**

路由：是指数据包从源主机到目标主机的路径选择过程。

静态路由：由**网络管理员手动配置的路由条目**，**路径固定**，不会自动适应网络拓扑变化。

动态路由：**路由器通过路由协议**（如OSPF、BGP）自动学习并更新路由表，适应网络变化。

- RIP协议使用 **向量-距离** 算法，OSPF协议使用 **链路-状态** 算法

RIP算法：向量-距离算法，基于跳数计算路径。**适合在小型的、动态的互联网上使用。**

OSPF算法：链路-状态算法，基于拓扑数据库计算路径。**适合于在大型的、动态的互联网上使用。**

- 为了使服务器能够响应并发请求，在服务器实现中通常可以采取两种解决方案，一种是 **重复服务器方案**，另一种是 **并发服务器方案。**
- MAC 地址通常存储在计算机的 **网卡**

以太网交换机中的端口/MAC地址映射表：**是交换机在数据转发过程中通过学习动态建立的。**

- **对IP数据报分片的重组通常发送在 目的主机 上**

分片的目的：不同网络的MTU可能不同，如果数据报大小 > 路径中的最小MTU，则必须分片才能传输。

源主机：**主动分片**，将大数据报拆分成多个小分片

目的主机：重组，收集所有的分片，按偏移量重新组合为原始数据报

**分片是发送行为，重组是接收行为。**

- **MAC地址和IP地址的作用**

MAC地址**用于局域网内的设备识别和通信。** 每个 **网络接口设备（如网卡）** 都有一个**唯一的MAC地址**，通常由制造商分配。**这个地址确保设备在局域网中能够被唯一标识。** MAC地址允许设备在同一局域网中通过以太网帧直接通信。**数据包通过MAC地址寻址，从源设备传输到目标设备。**

IP地址**用于在不同的网络之间进行通信。IP地址提供了一种逻辑寻址机制，使得设备可以在互联网上互相找到。** 不同的设备在不同网络中可有相同的MAC地址，但IP地址在全球范围内是唯一的。

- **路由器 交换机**

数据包传输路径：**客户端 —> 交换机（MAC转发） —> 路由器（IP路由）—> … … —> 目标服务器**

前置：**网卡将二进制数据转换为电信号（有线）或电磁波（无线），通过物理介质（网线、光纤）发送到交换机。**

**交换机**  交换机基于**MAC地址表**转发数据帧。收到数据帧后，交换机执行以下操作：

1、**学习MAC地址**：记录源MAC地址与接收端口的映射（如MAC_A → Port 1）。

**2、查找目标MAC地址**：若目标MAC存在于表中（如目标MAC是网关的MAC_B），则从对应端口（如Port 2）转发。若目标MAC未知，广播到所有端口（泛洪）。

**3、转发数据帧**：将电信号从目标端口发送到下一设备（如路由器）。

**路由器** 路由器基于 **路由表** 决定下一跳地址，处理流程如下：

**1、接收数据包**：路由器从某个接口（如eth0）收到数据包，剥离链路层帧头，解析IP头部。

**2、路由表查询**：根据目标IP地址匹配路由表中的条目，决定下一跳地址和出口接口。

**3、转发数据包**：重新封装链路层帧头（源MAC为路由器出口接口的MAC，目标MAC为下一跳设备的MAC）。将数据包从出口接口（如eth1）发送到下一跳设备。

- **CDN服务**

CDN 是一个**内容分发网络，** 通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的功能。

也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器**将请求定位到最近的含有该资源的服务器上去请求。**

这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。

- **怎么实现多个网站之间共享登录状态？**

在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

我认为单点登录可以这样来实现：

首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发送的账号密码的正确性。

然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该token 具有一定的有效时限。

当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将页面重定向会单点登录页面。

# 2 应用层 HTTP

**HTTP 超文本传输协议，是一个在计算机世界里专门在「两点之间传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

## 2.1 HTTP常见状态码

### 1XX

**提示信息**，是协议处理中的一种**中间状态**，实际用到的比较少。

[100 Continue] 服务器已接收请求的初步部分，客户端应继续请求。

[101 Switching Protocols] **服务器同意切换协议，如从HTTP切换到WebSocket。**

### 2XX

「**200 OK**」是最常见的**成功状态码**，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。

「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，**表示响应返回的 body 数据并不是资源的全部，而是其中的一部分**，也是服务器处理成功的状态。

### 3XX

**「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，** 需改用新的 URL 再次访问。

**「302 Found」表示临时重定向，** 说明请求的资源还在，但暂时需要用另一个 URL 来访问。

### 4XX

4xx类状态码表示客户端发送的**报文有误，服务器无法处理。**

「**400 Bad Request**」表示**客户端请求的报文有错误**，但只是个笼统的错误。

「**403 Forbidden**」表示服务器**禁止访问资源，并不是客户端的请求出错。**

「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

### 5XX

5xx类状态码表示客户端请求的报文正确，**但服务器处理时内部发生了错误。**

「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

**「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。**

**「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，** 表示服务器自身工作正常，访问后端服务器发生了错误。

**「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，**类似“网络服务正忙，请稍后重试”的意思。

## 2.2 HTTP协议

HTTP 具有简单、灵活、易用、通用等特点，是一种广泛应用于 Web 通信的协议。

**基于文本：** HTTP的消息是以文本形式传输，易于阅读和调试，但相比二进制协议效率较低。

**可扩展性**：HTTP协议本身不限制数据的内容和格式，可以**通过扩展头部、方法等来支持新的功能。**

**灵活性：** HTTP支持不同的数据格式（如HTML、JSON、XML等），适用于多种应用场景。

**无状态：** 每个请求之间相互独立，**服务器不会保留之前请求的状态信息**，需要通过其他手段（如Cookies、Session）来维护状态。**关键是每个请求之间相互独立，服务器不会在不同请求之间保护客户端的状态信息。**

### HTTP/1.0和HTTP/1.1的区别

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled.png)

1、连接方式：HTTP/1.0 为**短连接**，HTTP/1.1 支持**长连接**。HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。

**2、状态响应码** : HTTP/1.1 中**新加入了大量的状态码，** 光是错误响应状态码就新增了 24 种。举例 409 Conflict:请求与服务器当前状态冲突 **（如上传文件时资源已经被修改）**

**3、缓存机制 :** 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准。HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

4、**带宽（range头域，只请求资源的部分）：** HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。

HTTP/1.1 则在**请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content）**，**这样就方便了开发者自由的选择以便于充分利用带宽和连接。**

**5、Host头：** HTTP/1.1 引入了 Host 头字段，**允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能**。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

**补充：HTTP/1.1 的缺点**

在同一个TCP连接里面，数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面的请求的响应特别慢的话，就会造成许多请求排队等待的情况，这就是“队头阻塞”。

### HTTP/1.1和HTTP/2.0的区别？

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled%201.png)

**1、多路复用（Multiplexing）**：HTTP/2.0 在同一连接上**可以同时传输多个请求和响应**（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。

2、**二进制帧（Binary Frames）：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。**

**3、头部压缩：** HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。

**4、服务器推送（Server Push）：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，** 从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。 

**注：多路复用   在一个连接里，客户端和服务器都可以同时发送多个请求或回 应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。**

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled%202.png)

### HTTP/2.0和HTTP/3.0有什么区别？

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled%203.png)

**1、传输协议：** HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 **QUIC（Quick UDP Internet Connections） 协议** 来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。

2、**连接建立：** HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）**连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。**

**3、无队头阻塞：（不可忽略）HTTP/2.0 多请求复用一个 TCP 连接**，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

**一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。因此不存在队头阻塞问题。**

注：HTTP/1.0、HTTP/2.0和HTTP/3.0的协议栈的比较：

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled%204.png)

**（非常重要！！！）HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。**

### QUIC协议

QUIC（Quick UDP Internet Connections）：旨在解决 TCP 和 TLS 的局限性。**HTTP/3.0 使用 QUIC 作为其传输协议，取代了 HTTP/2.0 中的 TCP。**

- **主要特点**

**基于UDP ：** QUIC 使用 UDP 而非 TCP，避免了 TCP 的队头阻塞问题。

**内置加密：QUIC 默认使用 TLS 1.3 加密所有数据，提供更高的安全性。**

多路复用：QUIC 支持多路复用，允许多个数据流独立传输，减少延迟。

快速握手：QUIC 的握手过程比 TCP + TLS 更快，通常只需 0-RTT 或 1-RTT。

- **工作原理**

连接建立：QUIC 使用 0-RTT 或 1-RTT 握手，减少连接建立时间。

数据传输：通过独立的流传输数据，每个流都有自己的流控制，避免队头阻塞。

错误恢复：QUIC 使用前向纠错（FEC）和快速重传机制，提高数据传输的可靠性。

## 2.3 HTTP内容

### HTTP请求报文

**请求报文格式**

```java

GET / HTTP/1.1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

**请求行（Request Line）**

1、请求方法（Request Method）：**如 GET、POST、PUT、DELETE 等**。

GET的语义是请求获取指定的资源。GET方法是**安全、幂等、可被缓存的**

POST的语义是根据请求复合（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST**不安全、不幂等、（大部分）不可缓存**

2、请求目标（Request Target）：通常是 **URL 的路径部分**。

3、HTTP 版本（HTTP Version）：如 HTTP/1.1 或 HTTP/2。

**请求头（Request Headers）**

请求头包含了一系列的 **键值对**，用于传递额外的信息。常见的请求头包括：

**1、Host 字段：**客户端发送请求时，用来**指定服务器的域名。**

**2、Content-Length 字段：** Content-Length 字段，表明**本次回应的数据长度。**

3、Connection 字段：Connection 字段最常用于客户端要求服务器使用「HTTP 长连接」机制。

4、Content-Type 字段：Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

**5、Content-Encoding 字段：** Content-Encoding 字段说明**数据的压缩方法。** 表示服务器返回的数据使用了什么压缩格式。

**请求体（Request Body）**

请求体包含客户端发送给服务器的数据，通常用于 POST、PUT 等方法。请求体的格式由 Content-Type 头指定。

1、表单数据（Form Data）：application/x-www-form-urlencoded 或 multipart/form-data。

**2、JSON 数据：application/json。**

3、XML 数据：application/xml。

4、二进制数据：application/octet-stream。

### HTTP响应报文

**响应报文格式**

```java
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

**状态行**

协议版本字段、状态码、状态信息

**响应头**

首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。

常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。

常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。

常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。

常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修 改时间。

**响应体**

返回一些关键数据。

### 服务端解析HTTP请求数据的过程

- **接收原始数据**

服务端通过网络套接字（Socket）接收客户端发送的原始字节流。这些字节流包含了完整的 HTTP 请求数据。

- **解析请求行**

服务端首先解析请求行，提取出请求方法、请求目标和 HTTP 版本。

- **解析请求头**

服务端逐行解析请求头，提取出各个键值对。请求头以空行（\r\n）结束。

- **解析请求体**

如果请求方法包含请求体（如 POST、PUT），服务端会根据 Content-Length 或 Transfer-Encoding 头来确定请求体的大小和格式，然后读取并解析请求体。

- **处理请求**

服务端根据解析出的请求方法、请求目标、请求头和请求体，执行相应的业务逻辑。

**GET 请求：通常用于获取资源，服务端返回请求的资源。**

**POST 请求：通常用于提交数据，服务端处理数据并返回结果。**

- **生成响应**

服务端处理完请求后，生成 HTTP 响应，包括状态行、响应头和响应体。

## 2.4 HTTP缓存技术

对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对 **「请求-响应」** 的数据都**缓存在本地**，那么下次就直接读取本地的数据。

### 强制缓存

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，**决定是否使用缓存的主动性在于浏览器这边。**

强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
• `Cache-Control`， 是一个相对时间；
• `Expires`，是一个绝对时间；

**Cache-Control 的优先级高于 Expires** 。

### 协商缓存

某些请求的响应码是 `304`，这个是告诉浏览器**可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。**

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%202.png)

## 2.5 HTTP协议与RPC协议

TCP是传输层的协议，而基于TCP造出来的HTTP和各类RPC协议，它们都只是定义了不同消息格式的应用层协议。

**RPC（Remote Procedure Call）远程过程调用**，它本身并不是一个具体的协议，而是一种**调用方式**。**虽然大部分RPC协议底层使用TCP，但实际上它们不一定非得使用TCP，改用UDP或HTTP，其实也可以做到类似的功能。**

- **二者区别**

**1、服务发现：** HTTP中通过DNS服务去解析得到它背后的IP地址，RPC一般会有专门的中间服务去保存服务名和IP信息。

**2、传输的内容：** HTTP在网络上传输要序列化和反序列化，RPC定制化程度更高，可以采用更小的数据，性能更好

## 2.6 HTTP协议与WebSocket

**WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。**

WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器**仅需一次握手**，两者之间就直接可以**创建持久性的连接，并进行双向数据传输。**

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/889ff9c9-041f-4b00-96f3-02f6f11ccdcb.png)

WebSocket 和 HTTP 两者都是**基于 TCP 的应用层协议，都可以在网络中传输数据。**

### **主要区别**

- **WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。** 并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。
- **WebSocket 使用 ws:// 或 wss://**（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。
- **WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议**，如支持压缩、加密等。
- **WebSocket 通信数据格式比较轻量，而 HTTP 通信每次都要携带完整的头部，** 网络开销较大。

### WebSocket底层原理(怎么建立WebSocket连接)

浏览器和服务器建立一个websocket连接，它需要发送一个HTTP请求，并且**会在这个HTTP请求里带上一些特殊的header头，** 如下：（必须得是GET,且具有Host属性）

![屏幕截图 2025-02-08 214549.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-02-08_214549.png)

↑这个header头的意思是，浏览器想升级协议（Connection Upgrade）,并且想升级成WebSocket协议。同时带上一段随机生成的base64码给服务器

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%203.png)

服务器支持的话，就会走WebSocket握手流程，同时根据客户端生成的base64编码，响应另一段编码，**状态码是101（这个不常见，是协议切换的意思）**

经过一来一回两次HTTP握手，WebSocket就建立完成了，后续双方就可以使用websocket的数据格式来进行通信了。

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%204.png)

### websocket的使用场景

用于需要服务器和客户端频繁交互的大部分场景，网页/小程序游戏等 

### WebSocket因为异常断开连接怎么办

- **自动重连机制**

实现方式：在 onclose 事件中设置重连逻辑，使用 setTimeout 或 set-Interval 进行延迟重连。

重连次数限制：避免无限重连，设置最大重试次数

- **心跳机制**

定期发送心跳包，检测连接状态，防止因超时断开。

- **错误处理**

捕获并处理错误，记录日志以便排查问题。在 onerror 事件中处理错误。

## 2.7 HTTPS

### HTTP 与 HTTPS 的区别？

- **安全性：** HTTP数据以明文形式传输，容易被窃听和篡改。HTTPS 数据通过 SSL/TLS 协议加密传输，防止窃听和篡改。
- **协议与端口号：** HTTP使用 HTTP 协议 , **默认端口号为 80**。HTTPS 使用 HTTP 协议，并通过 SSL/TLS 协议进行加密。**默认端口号为 443。**
- **性能：** HTTP：由于没有加密和解密过程，性能较高，传输速度较快。HTTPS：由于加密和解密过程，性能较低，传输速度较慢。

HTTPS在HTTP与TCP之间加入了**SSL/TLS（Secure Sockets Layer/Transport Layer Security）协议**，可以解决HTTP的：
• **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
• **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
• **冒充风险**，比如冒充淘宝网站，用户钱容易没。

**先建立TCP连接,在建立SSL/TLS连接。**

### 混合加密

通过**混合加密**的方式可以保证信息的 **机密性** ，**解决了窃听的风险。**

**对称加密与非对称加密**

- 对称加密只使用一个密钥，**运算速度快**，**密钥必须保密**，无法做到安全的密钥交换 加密解密都是用同一种方法
- 非对称加密使用两个密钥：公钥和私钥，**公钥可以任意分发**，而**私钥保密，**解决了密钥交换问题但速度慢（如下图、加密用公钥，解密用私钥）

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled%205.png)

HTTPS采用混合加密方式；**对称加密** 和 **非对称加密** 结合
在 **通信建立前（四次握手）** 采用 **非对称加密**的方式**交换「会话秘钥」**，后续就不再使用非对称加密。
在 **通信过程中** 全部使用**对称加密** 的 **「会话秘钥」的方式加密明文数据。**

### 摘要算法+数字签名

无法篡改通信内容，篡改了就不能正常显示，解决了篡改风险

**用 摘要算法（哈希函数） 来计算出内容的哈希值（哈希值是唯一的，且无法通过哈希值推导出内容）**

接收端接受到内容后，也会对内容进行计算哈希值，最后比较这两哈希值是否相等。

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled%206.png)

**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密。**

- 可以通过哈希算法来 **保证消息的完整性；**
- 可以通过数字签名来 **保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；**

### 数字证书（好好看看!）

数字证书的方式保证服务器公钥的身份，解决**冒充**的风险。

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled%207.png)

数字证书 = **服务器的公钥** + CA(数字证书认证机构)的数字签名

Step1、服务器把自己的公钥注册到CA **（服务端生成一对非对称密钥：私钥和公钥）**

Step2、CA用自己的私钥，将服务器的公钥数字签名，并颁发**数字证书（证书包含服务端公钥、域名信息、有效期、CA的签名）**

Step3、客户端拿到服务器的数字证书后，使用CA的公钥确认服务器的数字证书的真实性。

Step4、从数字证书获取服务器公钥后，使用它对报文加密后发送

Step5、服务器用私钥对报文进行解密。

### HTTPS 四次握手

![Untitled](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/Untitled%208.png)

**1. ClientHello**

由**客户端向服务器**发起加密通信请求，客户端主要向服务器发送以下信息：

（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

（2）**客户端生产的随机数（`Client Random`**），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

**2. SeverHello**

服务器收到客户端请求后，向客户端发出响应。(服务端 → 客户端)
（1）确认 TLS 协议版本，（对应ClientHello的(1)）如果浏览器不支持，则关闭加密通信。

**（2）服务器生产的随机数（`Server Random`）**，也是后面用于生产「会话秘钥」条件之一。

（3）确认的密码套件列表，如 RSA 加密算法。（对应ClientHello的(3)）

**（4）服务器的数字证书。**

**3.客户端回应**

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，**确认服务器的数字证书的真实性。**
如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：
（1）**一个随机数（`pre-master key`）**。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。
**服务器和客户端有了这三个随机数Client Random、Server Random、pre-master key。接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

**4. 服务器的最后回应**

服务器收到客户端的**第三个随机数（`pre-master key`）**之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。
然后，向客户端发送最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用 **「会话秘钥」加密通信**。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

总结一下，就是两端都会收集**客户端生产的随机数（`Client Random`**）、**服务器生产的随机数（`Server Random`）**、  **一个随机数（`pre-master key`）** 生成会话密钥。后续都用这个会话密钥进行加密通信。

# 3 传输层 TCP

## 3.1 TCP基本认识（头格式）

### **什么是TCP？**

**TCP是 面向连接的**、**可靠的**、**基于字节流** 的**传输层通信协议。** TCP通过 **提供可靠传输、流量控制、拥塞控制和连接管理**，解决了**数据在 不可靠的IP网络上 传输的问题。**

建立一个 **TCP连接** 是需要客户端与服务端达成三个信息的共识：

**1、Socket :** 由IP地址和端口号组成

**2、序列号：** 用于解决乱序问题

**3、窗口大小：** 用来做流量控制

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%205.png)

- 序列号：在建立连接时，由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，用于**解决网络包乱序问题。**
- 确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**
- 控制位：ACK\SYN\FIN\ **RST:该位为1时，表示TCP连接中出现异常必须强制断开连接。**

### 如何唯一确定一个TCP连接

TCP四元组可以唯一确定一个连接，四元组包括如下：**源地址**、**目标地址（在IP头部中，作用是通过IP协议发送报文给对方主机）**。**源端口和目的端口（在TCP头部中，作用是告诉TCP协议应该把报文发给哪个进程）**

## **3.2 TCP和UDP的区别**

- **连接**  TCP 是面向连接的传输层协议，传输数据前**先要建立连接。** UDP 是不需要连接，**即刻传输数据。**
- **服务对象**  TCP 是 **一对一的两点服务，即 一条连接**只有两个端点。UDP **支持一对一、一对多、多对多**的交互通信。
- **可靠性**  TCP 是**可靠交付数据的，** 数据可以无差错、不丢失、不重复、按序到达。UDP 是**尽最大努力交付**，不保证可靠交付数据。
- **拥塞控制、流量控制** TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
- **首部开销 TCP 首部长度较长，会有一定的开销，UDP 首部只有 8 个字节，并且是固定不变的，开销较小。**

TCP头部有【首部长度】字段，TCP有可变长的选项字段，UDP头部没有【首部长度】字段，因为它是固定长度的。

- **传输方式  TCP是面向字节流的协议，应用程序通过TCP发送的数据被视为连续的字节流。UDP是面向报文的协议，每个UDP数据报都是独立的实体。**
- **分片不同**

TCP 的数据大小如果大于 MSS 大小，则会在 **传输层进行分片**，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。

UDP 的数据大小如果大于 MTU 大小，则会在 **IP 层进行分片**，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

**总结：** TCP是面向连接（HTTP/HTTPS），UDP通常用于视频、音频等多媒体通信。

## 3.3 TCP三次握手

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%206.png)

### 1 握手为什么需要三次？

1、三次握手才可以 **阻止重复历史连接的初始化（主要原因）**

在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。

**2、同步双方初始化序列号**

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素。

**3、避免资源浪费**

### 2 为什么每次建立TCP连接，初始化的序列号都要求不一样呢？

**1、为了防止历史报文被下一个相同的四元组接收。**

2、为了安全性，防止黑客伪造的相同序列号的TCP报文被对方接收。

### 3 既然IP层会分片，为什么TCP层还需要MSS呢？

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/eee085d7-91c9-4c7d-9453-045fb298fb03.png)

MTU ：一个网络包的最大长度，以太网中一般为1500字节。

MSS ： 除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度 。

当IP层有一个超过MTU大小的数据（TCP头部 + TCP数据）要发送，**那么IP层就要进行分片，把数据分片成若干片，保证每一个分片都小于MTU，把一份数据报进行分片以后，由目标主机的IP层来进行重新组装后，再交由上一层TCP传输层。**

存在问题：当一个IP分片丢失，整个IP报文的所有分片都得重传。

**为了达到最佳的传输效能，** 故也在TCP层进行分片： TCP 层发现数据超过 MSS 时，则就先会进行分片，经过 TCP 层分片后，如果一个 TCP 分片丢失后，**进行重发时也是以 MSS 为单位**，而不用重传所有的分片，大大增加了重传的效率。

### 4 握手丢失会发生什么？

- **第一次握手丢失**

客户端向服务端建立TCP连接，首先第一个发的就是SYN报文。然后进入SYN_SENT状态。

在这之后，如果客户端迟迟收不到服务端的SYN-ACK报文，就会触发 **【超时重传】** 机制，重传SYN报文。重传报文的序列号都是一样的。

重传次数是可以自定义的，默认值是5；**通常，每次超时时间是上一次的2倍。**

- **第二次握手丢失**

服务端向客户端发送 SYN-ACK 报文，此时服务端会进入 SYN_RCVD 状态。如果客户端迟迟没有收到第二次握手，客户端就可能觉得自己的SYN报文（第一次握手）丢失了，**于是客户端会触发超时重传机制，重传SYN报文。**

由于第二次握手包含服务端的SYN报文，如果第二次握手丢失了，服务端就收不到第三次握手，**服务端会触发超时重传机制，重传SYN-ACK报文。重传次数由内核参数决定。**

总结：**当第二次握手丢失时，客户端和服务端都会重传，客户端会重传SYN报文，服务端会重传SYN-ACK报文。**

- **第三次握手丢失**

客户端接收到服务端的SYN-ACK报文后，就会给服务端回一个ACK报文，此时客户端进入到ESTABLISH状态。

进入ESTABLISH状态后，**客户端可以发送数据，但服务端不会处理**

如果服务端迟迟接收不到这个确认报文，就会触发超时重试机制，重传SYN-ACK报文。

**总结：反正ACK报文不会重传，但SYN、SYN-ACK报文会重传，还有重传次数一般都是由参数控制，而且每一次超时时间都是上一次的两倍。**

### 5 发送SYN之后就宕机了会怎么样？

Client发送SYN至Server之后宕机了，此时Server发送SYN+ACK救抑制得不到回复，此时会进行阶段性重试。多次重试后还没有收到ACK会断开连接，释放资源。

### 6 SYN攻击，如何避免SYN攻击

SYN攻击：攻击者短时间内伪造不同IP地址的SYN报文，服务端每接收到一个报文就会进入SYN_RCVD状态，但服务端发送出去的报文，无法得到未知IP主机的ACK应答，久而久之就会 **【占满服务端的半连接队列】**，使得服务端不能为正常用户服务。

在TCP三次握手的时候，内核会维护两个队列，分别是：

1、半连接队列，也称SYN队列 

2、全连接队列，也称accept队列。

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%207.png)

---

避免SYN攻击：1、增大TCP半连接队列

2、减少SYN-ACK重传次数

### 7 初始序列号如何生成的？

ISN生成方式（现代操作系统实现）：**基于哈希的随机化算法（主流实现）**

- **基准值**：每毫秒或每时钟滴答递增的计数器
- **哈希输入**：通常包括源/目的IP、端口、随机秘密值
- **目的**：使外部难以预测序列号

```java
ISN = (基准值 + 哈希(四元组+随机盐)) % 2^32
```

## 3.4 TCP 连接断开

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%208.png)

客户端打算关闭连接，此时会发送一个 TCP 首部 **`FIN` 标志位被置为 `1` 的报文**，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。

服务端收到该报文后，就向客户端发送 `ACK` 应答报文，**等待服务端处理完数据后，**也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。

客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态，**主动关闭连接的，才有 TIME_WAIT 状态。**

### 1 为什么挥手需要四次

服务端通常需要等待完成数据的发送和处理，所以服务端的ACK和FIN一般都会分开发送，因此需要四次挥手。

### 2 挥手丢失

- **第一次挥手丢失**

客户端收不到服务端发送的ACK的话，会触发超时重传机制（重传FIN报文）。

- **第二次挥手丢失**

ACK报文是不会重传的，当第二次挥手丢失时，客户端重传FIN报文。

- **第三次挥手丢失**

第三次挥手是服务端向客户端发送FIN报文，同时，连接进入LAST_ACK状态，等待客户端返回ACK来确认连接关闭。

如果迟迟收不到到的话，会触发重传机制。

- **第四次挥手丢失**

客户端收到服务端的第三次挥手的FIN报文后，就会回ACK报文，此时客户端处于 **TIME_WAIT** 状态。

客户端 TIME_WAIT  状态会持续2MSL后才会进入关闭状态。如果途中再收到第三次挥手的报文，就会重置定时器，当等待2MSL时长后，客户端就会断开连接。

服务端没有接收到ACK报文前，还是处于LAST_ACK状态。服务端依然会重发FIN报文，重发次数仍然由参数控制。如果达到最大重试次数还没有收到客户端的ACK，直接断开连接。

### 3 为什么TIME_WAIT等待时间是2MSL?

**MSL是报文最大生成时间，** 网络中可能存在来自发送方的数据包，当这些发送方的数据报被接收方处理后又会向对方发送响应，所以一来一回需要等待2倍的时间。**（2MSL时长相当于运行报文至少丢一次）**

有默认值的，Linux中2MSL默认是60秒，Windows通常是2分钟。

### 4 为什么TCP挥手需要有TIME_WAIT状态？

- **确保最后的ACK到达：** 防止主动关闭方发送的最后一个ACK丢失，导致被动关闭方重传FIN，影响新连接。TIME_WAIT状态持续2MSL（Maximum Segment Lifetime），确保有足够时间处理延迟或丢失的报文。
- **防止旧连接的数据混淆：** 避免旧连接的延迟报文与新连接的报文混淆。2MSL时间确保网络中所有旧连接的报文都已消失，防止它们被误认为新连接的数据。
- **确保双方完全关闭 ：** 保证双方都完成关闭操作，避免一方未完全关闭导致资源泄漏。

### 5 除了四次挥手，还有什么方法断开连接？

- **RST（Reset标志）**

使用TCP RST标志可以强制立即终结连接，**发送方可以直接发送带有RST标志的TCP报文，通知对方立即断开连接。**

- **超时（Timeout）**

如果连接一段时间内没有任何数据包传输，连接双方可以依据设定的超时时间自动断开连接。

### 6 TIME_WAIT过多会有什么危害？

1、占用系统资源，比如文件描述符、内存资源、CPU资源、线程资源等

2、占用端口资源

### 7 服务器出现大量TIME_WAIT状态的原因？

说明服务器主动断开了很多TCP连接。

场景1：HTTP没有使用长连接：

场景2：HTTP长连接超时

场景3：HTTP长连接的请求数量达到上限

### 8 如果已经建立连接，但是客户端突然出现故障了怎么办

客户端主机发生了宕机，如果服务端一直不会发送数据给客户端，那么服务端永远无法感知到客户端宕机这个事件的，会占用系统资源。

↑为了避免这种情况，TCP使用 **保活机制**。

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文（数据非常少）如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡。系统内核将错误信息通知给上层应用程序。

### 9 如果已经建立了连接，服务端进程崩溃？

**TCP连接信息是由内核维护的**。当进程崩溃后，内核1需要回收该进程的所有TCP连接资源。

**内核会发送第一次挥手FIN报文，后续的挥手过程也都是在内核完成**，并不需要进程的参与。

## 3.5 TCP重传、滑动窗口、流量控制、拥塞控制

### 重传机制

TCP 实现可靠传输的方式之一，是通过序列号与确认应答。在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。

常见的重传机制：

- **超时重传**  —> **数据包丢失、确认应答丢失**
- **快速重传** —>  **不以时间为驱动、而是以数据驱动重传**

---

TCP的超时重传和快速重传是两种不同的机制，各自适用于不同的场景，**快速重传是对超时重传的补充，主要为了提升效率。**

超时重传：发送方在发送数据后启动定时器，若在**超时时间内未收到ACK**，则重传数据。

快速重传：当接收方收到乱序报文时，**会重复发送对缺失报文的ACK。发送方收到3个重复ACK后，立即重传缺失报文，而不必等待超时。**

降低延迟: 快速重传无需等待超时，能更快恢复数据传输。

提高效率: 在网络轻微拥塞或少量丢包时，快速重传能更快修复数据流。

---

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%209.png)

### 超时时间 RTO

RTT：**数据发送时刻到接收到确认的时刻的差值**，也就是**包的往返时间。**

**RTO：超时重传时间RTO的值应该略大于报文往返RTT的值。**

实际TCP策略是超时间隔加倍：也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。

### SACK（ Selective Acknowledgment）， **选择性确认**。

↑  针对【快速重传】可能存在的问题，**重传的时候是重传一个，还是重传所有的问题。**（比如客户端连续接收到3个ACK2报文，是重传Seq2一个，还是重传Seq2之后所有的报文？）

这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2010.png)

SACK 的引入是为了**允许接收方通过SACK选项告知发送方已成功接收的非连续数据段**，发送方只需重传真正丢失的数据包，从而：提高丢包恢复效率。减少不必要的重传，提升网络利用率。降低延迟，改善实时应用的性能。

- D-SACK

Duplicate SACK : 主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**D-SACK通过在 SACK选项 的第一个块中报告重复接收的数据段信息。

### 流量控制 — 滑动窗口

**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

- **滑动窗口是实现流量控制的核心机制。**

TCP滑动窗口机制主要作用是实现**流量控制（Flow Control）**，即协调发送方和接收方的数据传输速率，**确保发送方不会发送超过接收方处理能力的数据量，**防止接收端缓冲区溢出。

TCP 头里有一个字段叫 `Window`，也就是窗口大小。**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**

- 接收窗口和发送窗口的大小是相等的吗？

**并不完全相等，接收窗口的大小是约等于发送窗口的大小的。**

### 拥塞控制

**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

**拥塞控制 : 避免「发送方」的数据填满整个网络。**

**拥塞窗口：拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。**

- 拥塞窗口和发送窗口有什么关系？

**发送窗口swnd = min(接收窗口rwnd,拥塞窗口cwnd)**

- 拥塞窗口 `cwnd` 变化的规则：

只要网络中没有出现拥塞，`cwnd` 就会增大；但网络中出现了拥塞，`cwnd` 就减少；

- 怎么知道当前网络是否出现了拥塞：

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞。**

### 拥塞控制算法

**Step1、慢启动 （Slow Start）**

**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。直至到达慢启动门限。**

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2011.png)

**Step2、拥塞避免（Congestion Avoidance）**

**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2012.png)

**Step3、拥塞发生**

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

- 超时重传
- 快速重传

**当发生了「超时重传」，则就会使用拥塞发生算法。**

这个时候，ssthresh 和 cwnd 的值会发生变化：
1、 `ssthresh` 设为 `cwnd/2`，

2、 `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2013.png)

**Step4、快速恢复**

快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 `RTO` 超时那么强烈。

进入快速恢复之前，`cwnd` 和 `ssthresh` 已被更新了：
1、`cwnd = cwnd/2` ，也就是设置为原来的一半;

2、ssthresh = cwnd

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2014.png)

- **总结：TCP怎么保证可靠传输**

1、重传机制：超时重传/快速重传

2、流量控制

3、拥塞控制

**4、连接管理：三次握手、序列号与确认应答。**

## **3.6 TCP沾包与TCP拆包**

在TCP网络通信中，**TCP粘包（Packet Stitching）** 和 **TCP拆包（Packet Splitting）** 是两个常见的问题。

- **粘包**是指**发送方发送的多个数据包在接收方接收到时被粘在一起，接收方无法区分各个数据包的边界**。粘包现象通常发生在发送端连续发送数据且发送数据的频率很高时。
- **拆包**是指发送方发送的一个数据包在**接收方接收到时被拆分成了多个部分，**接收方需要重新组装这些部分才能得到完整的数据包。**拆包现象通常发生在发送的数据包过大**，超过了TCP的最大传输单元（MTU）时。**拆包其实是一种正常现象。**
- **半包问题**：一个完整的数据包只有部分到达接收方

**原因：网络不稳定导致部分数据丢失、接收缓冲区大小不足。**

### 如何解决粘包问题（可结合RPC项目）

- **特殊字符做边界：** 我们可以在两个用户消息之间插入一个特殊字符，这样接收方在接收到数据时，读到这个特殊字符，就认为已经读完一个完整的消息。**HTTP通过设置回车符、换行符作为HTTP报文协议的边界。**
- 自定义消息结构

## 3.7 情景题

### 1 已经建立连接的TCP，收到SYN会发生什么？

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2015.png)

# 4 网络层IP

网络层的主要作用：实现主机与主机之间的通信，也叫**点对点通信**

网络层与数据链路层有什么关系？**MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。**

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2016.png)

旅行途中，虽然我们不断变化了交通工具，但是旅行行程的起始地址和目的地址始终都没变。**网络中的数据包也是，源IP地址和目标IP地址在传输过程中是不会变化的（前提是没有使用NAT网络），只有源MAC地址和目标MAC一直在变化。**

## 4.1 IP协议基础知识

作用：主要作用是定义数据包的格式、对数据包进行**路由和寻址**，**以便它们可以跨网络传播并到达正确的目的地。**

### IP地址分类

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2017.png)

对于 A、B、C 类主要分为两个部分，分别是**网络号和主机号。**因为在 IP 地址中，有两个 IP 是特殊的，**分别是主机号全为 1 和 全为 0 地址。**

---

• 主机号全为 1 指定**某个网络下的所有主机，用于广播（广播地址用于在同一个链路中相互连接的主机之间发送数据包。）**

广播地址又可以分为：本地广播和直接广播

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/b12cfd9d-6b16-4ce4-8101-23896b2e8f82.png)

•主机号全为 0 指定**某个网络**

---

D 类和 E 类地址是没有主机号的，所以**不可用于主机 IP**，**D 类常被用于多播，E 类是预留的分类，暂时未使用。**

多播用于**将包发送给特定组内的所有主机。**

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2018.png)

多播可以直接穿透路由

### IP分类的优点

不管是路由器还是主机解析到一个IP的时候，我们判断其IP地址，如下：

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2019.png)

快速判断

### IP分类的缺点

**缺点一：同一网络下没有地址层次，** 比如使用了B类地址，但可能根据需要还需要划分为生产环境、测试环境和开发环境

**缺点二：不能很好与现实网络匹配，** C类地址太少了（254），而B类地址又太多了

### 无分类地址CIDR

32 比特的 IP 地址被划分为两部分，前面是**网络号**，后面是**主机号**。

怎么划分网络号和主机号的呢？

表示形式 `a.b.c.d/x`，其中 `/x` 表示前 x 位属于**网络号**，后面就是主机号。

还有一种划分网络号与主机号形式，就是子网掩码，**将子网掩码和IP地址按位计算AND，** 就可以得到网络号。

### 为什么要分离网络号和主机号？

因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。

### 子网划分？就是再度划分。

子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2020.png)

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2021.png)

### IP地址与路由控制

IP地址的网络地址这一部分是用于进行路由控制。路由控制表中记录着网络地址与下一步应该发送至路由器的地址。**在主机和路由器上都会有各自的路由器控制表。**

在发送IP包，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。

**如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。**

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/edcc973d-ea25-4b80-ac5c-c02ebb486fc2.png)

### 环回地址

环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。**环回地址是不会流向网络。**

计算机使用一个特殊的IP地址  127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做localhost的主机名。使用这个IP或主机名时，数据包是不会流向网络。

## 4.2 IP协议相关技术

### **DNS 协议 域名系统协议(详细过程)**

DNS协议（Domain Name System Protocol）是互联网协议套件中的一种，主要用于**将域名解析为IP地址。**

**概念：域名结构树**

![屏幕截图 2025-03-17 165424.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-03-17_165424.png)

域名结构树：最顶部是由一个点来表示的（根域名服务器 → 顶级域名服务器（com cn net gov）→ 权威域名服务器（bilinili qq baidu）

**DNS域名解析过程**

![屏幕截图 2025-03-17 170640.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-03-17_170640.png)

DNS 域名解析的过程和我们日常生活中找人问路的过程类似，**只指路不带路**。

**Step1、** 浏览器首先需要看看 **自己浏览器缓存** 有没有对应的ip记录。  有缓存则直接拿。然后会检查 **本地Hosts文件** 中有没有对应的ip地址。**[永远是先查本地记录]**

**Step2、** 发送解析请求到解析器DNS客户端，DNS客户端向DNS服务器发送请求。

**Step3、** 递归DNS服务器首先查询根域名服务器，获取负责顶级域（[如.com](http://xn--bvs.com/)）的顶级域名服务器地址。递归DNS服务器向顶级域名服务器查询，获取负责该域名的权威域名服务器地址。递归DNS服务器向权威域名服务器查询，获取域名对应的IP地址。

**Step4、** 将IP地址返回给用户的设备。DNS 基于 **UDP协议** 实现，**DNS使用UDP协议进行域名解析和数据传输。**

用户向本地DNS服务器发送请求属于 **递归请求**，本地DNS服务器向各级域名服务器发送请求属于 **迭代请求。**

**DNS特性**

**低延迟： UDP是一种无连接的协议，** 不需要在数据传输前建立连接，因此可以减少传输时延，适合DNS这种需要快速响应的应用场景。

**简单快速：** UDP相比于TCP更简单，没有TCP的连接管理和流量控制机制，传输效率更高，适合DNS这种需要快速传输数据的场景。

**轻量级**：UDP头部较小，占用较少的网络资源，对于小型请求和响应来说更加轻量级，适合DNS这种频繁且短小的数据交换。

**DNS污染（考过）**

DNS污染（DNS Spoofing/Poisoning）是指攻击者通过伪造DNS响应，将域名解析到错误的IP地址，导致用户访问到恶意网站或无法访问目标网站。

**预防措施**

1、使用可信的DNS服务器

2、配置防火墙规则

3、使用HTTPS

**DNS实现负载均衡**

DNS可以用于在冗余的服务器上实现负载平衡。现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。

当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在 每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。

以此将用户的请求均衡的分配到各个不 同的服务器上，这样来实现负载均衡。

### ARP

**ARP和RARP别搞混了**

在传输一个IP数据报的时候，确定了源IP地址和目标IP地址后，就会通过主机 **[路由表]** 确定IP数据包的下一跳。

由于主机的路由表中可以找到下一跳的 IP 地址，**所以可以通过 ARP 协议，求得下一跳的 MAC 地址。**
ARP 是借助  **ARP 请求  与  ARP 响应** 两种类型的包确定 MAC 地址的。

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2022.png)

具体过程：

1、主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。

2、当同个链路中的所有设备收到ARP请求时，会去拆开ARP请求包里的内容，如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个设备就将自己的MAC地址塞入ARP响应包返回给主机。

**注：操作系统通常会把第一次通过ARP获取的MAC地址缓存起来，以便下次直接从缓存中找到对应IP地址的MAC地址。**

### RARP

**已知 MAC 地址求 IP 地址**,例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。

设备会发送请求信息，RARP服务器接到这个消息后返回【MAC地址为XXXX的设备，IP地址为XXXX】的信息给这个设备。

### DHCP

电脑通常都是通过 DHCP **动态获取 IP 地址**，大大省去了配 IP 信息繁琐的过程。**DHCP 交互中，全程都是使用 UDP 广播通信。**

在TCP/IP网络中，每个设备必须有唯一的IP地址才能被其他设备识别。这里动态IP相比静态IP是有优势的，虽然IP地址在大多数情况下是不变的，但有些特殊情况（笔记本在不同网络中自动适配）

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2023.png)

1、客户端首先发起 **DHCP 发现报文（DHCP DISCOVER）** 的 IP 数据报

2、DHCP 服务器收到 DHCP 发现报文时，用 **DHCP 提供报文（DHCP OFFER）** 向客户端做出响应。

3、客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 **DHCP 请求报文（DHCP REQUEST）** 进行响应，回显配置参数

4、最后，服务端用 **DHCP ACK 报文**对 DHCP 请求报文进行响应，

### NAT

**网络地址转换 NAT** 的方法，再次缓解了 IPv4 地址耗尽的问题。

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2024.png)

简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时,把私有 IP 地址转换成公有 IP 地址。

### ICMP( **Internet Control Message Protocol**) 互联网控制报文协议

`ICMP` 主要的功能包括：**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。**

一类是用于诊断的查询消息，也就是「**查询报文类型**」，另一类是通知出错原因的错误消息，也就是「**差错报文类型**」

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2025.png)

### IGMP

组播：只有一组的主机能收到数据包，不在一组的主机不能收到数据包，怎么管理是否在一组，就需要用到IGMP协议。

![image.png](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207c938fdb403c4ee48e045f83ed672ecd/image%2026.png)

IGMP是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间。
